/*
 ***********************************************************************************************************************
 *
 *  Copyright (c) 2013-2018 Advanced Micro Devices, Inc. All Rights Reserved.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 **********************************************************************************************************************/

DefineEnum = "'BGFSEnableFlags' : ('BGFSEnableWddm1Immediate',   '0x0001'),
                                  ('BGFSEnableWddm1Mailbox',     '0x0002'),
                                  ('BGFSEnableWddm1Fifo',        '0x0004'),
                                  ('BGFSEnableWddm1FifoRelaxed', '0x0008'),
                                  ('BGFSEnableWddm2Immediate',   '0x0010'),
                                  ('BGFSEnableWddm2Mailbox',     '0x0020'),
                                  ('BGFSEnableWddm2Fifo',        '0x0040'),
                                  ('BGFSEnableWddm2FifoRelaxed', '0x0080'),
                                  ('BGFSEnableWddm1MultiGpu',    '0x0100'),
                                  ('BGFSEnableWddm2MultiGpu',    '0x0200');

DefineEnum = "'DevModeSqttMarkerEnableFlags' : ('DevModeSqttMarkerEnableCbStart',         '0x0001'),
                                               ('DevModeSqttMarkerEnableCbEnd',           '0x0002'),
                                               ('DevModeSqttMarkerEnableEvent',           '0x0004'),
                                               ('DevModeSqttMarkerEnableBarrier',         '0x0008'),
                                               ('DevModeSqttMarkerEnableGeneralApi',      '0x0010'),
                                               ('DevModeSqttMarkerEnableUserEvent',       '0x0020'),
                                               ('DevModeSqttMarkerEnableEventWithDims',   '0x0040');

DefineEnum = "'PipelineFastCompileMode' : ('PipelineFastCompileApiControlled',   '0'),
                                          ('PipelineFastCompileAlwaysFast',      '1'),
                                          ('PipelineFastCompileAlwaysOptimized', '2'),
                                          ('PipelineFastCompileAlwaysFastWithOptimized', '3'),";"

DefineEnum = "'PipelineBinningMode' : ('PipelineBinningModeDefault',  '0'),
                                      ('PipelineBinningModeDisable',  '1'),
                                      ('PipelineBinningModeEnable',   '2'),";"

DefineEnum = "'PipelineLinkTimeOptMode' : ('PipelineLinkTimeOptApiControlled',  '0'),
                                          ('PipelineLinkTimeOptAlwaysEnabled',  '1'),
                                          ('PipelineLinkTimeOptAlwaysDisabled', '2')";"

DefineEnum = "'IcdChillLevelMode' :('IcdChillLevelDisable', '0'),
                                   ('IcdChillLevelSubtle',  '1'),
                                   ('IcdChillLevelMedium',  '2'),
                                   ('IcdChillLevelFull',    '3')";

DefineEnum = "'LlpcMode' : ('LlpcModeScpcOnly',          '0'),
                           ('LlpcModeLlpcOnly',          '1'),
                           ('LlpcModeMixScpcInclusive',  '2'),
                           ('LlpcModeMixScpcExclusive',  '3'),
                           ('LlpcModeAutoFallback',      '4'),
                           ('LlpcModeMixScpcHashList',   '5'),
                           ('LlpcModeMixLlpcHashList',   '6')";

DefineEnum = "'ShaderReplaceMode': ('ShaderReplaceDisable',            '0'),
                                   ('ShaderReplaceShaderHash',         '1'),
                                   ('ShaderReplaceShaderPipelineHash', '2')";

DefineEnum = "'ShaderCacheMode': ('ShaderCacheDisable',                  '0'),
                                 ('ShaderCacheEnableRuntimeOnly',        '1'),
                                 ('ShaderCacheEnableOnDisk',             '2'),
                                 ('ShaderCacheForceInternalCacheOnDisk', '3')";

DefineEnum = "'PipelineDumpFilters' : ('PipelineDumpFilterNone',        '0x00')
                                      ('PipelineDumpFilterCs',          '0x01'),
                                      ('PipelineDumpFilterNgg',         '0x02'),
                                      ('PipelineDumpFilterGs',          '0x04'),
                                      ('PipelineDumpFilterTess',        '0x08'),
                                      ('PipelineDumpFilterVsPs',        '0x10')";

DefineEnum = "'ResourceBarrierOptions' :('DefaultResourceBarrier',         '0x0000'),
                                        ('CombinedAccessMasks',            '0x4000'),
                                        ('SkipDstCacheInv',                '0x8000'),
                                        ('PreferFlushOverInv',             '0x2000'),
                                        ('Gfx6KeepShaderCoher',            '0x0100'),
                                        ('Gfx6AvoidCpuMemoryCoher',        '0x0200'),
                                        ('Gfx9KeepShaderCoher',            '0x0400'),
                                        ('Gfx9AvoidCpuMemoryCoher',        '0x0800')";

DefineEnum = "'DbgBarrierCmd' : ('DbgBarrierDrawNonIndexed',            '0x00000001'),
                                ('DbgBarrierDrawIndexed',               '0x00000002'),
                                ('DbgBarrierDrawIndirect',              '0x00000004'),
                                ('DbgBarrierDispatch',                  '0x00000008'),
                                ('DbgBarrierDispatchIndirect',          '0x00000010'),
                                ('DbgBarrierCopyBuffer',                '0x00000020'),
                                ('DbgBarrierCopyImage',                 '0x00000040'),
                                ('DbgBarrierCopyQueryPool',             '0x00000080'),
                                ('DbgBarrierClearColor',                '0x00000100'),
                                ('DbgBarrierClearDepth',                '0x00000200'),
                                ('DbgBarrierResolve',                   '0x00000400'),
                                ('DbgBarrierBeginRenderPass',           '0x00000800'),
                                ('DbgBarrierNextSubpass',               '0x00001000'),
                                ('DbgBarrierEndRenderPass',             '0x00002000'),
                                ('DbgBarrierSetResetEvent',             '0x00004000'),
                                ('DbgBarrierPipelineBarrierWaitEvents', '0x00008000'),
                                ('DbgBarrierQueryBeginEnd',             '0x00010000'),
                                ('DbgBarrierQueryReset',                '0x00020000'),
                                ('DbgBarrierExecuteCommands',           '0x00040000'),
                                ('DbgBarrierCmdBufStart',               '0x00080000'),
                                ('DbgBarrierCmdBufEnd',                 '0x00100000'),
                                ('DbgBarrierBindPipeline',              '0x00200000'),
                                ('DbgBarrierBindSetsPushConstants',     '0x00400000'),
                                ('DbgBarrierBindIndexVertexBuffer',     '0x00800000'),
                                ('DbgBarrierWriteTimestamp',            '0x01000000'),
                                ('DbgBarrierSetDynamicPipelineState',   '0x02000000'),
                                ('DbgBarrierVideo',                     '0x04000000'),
                                ('DbgBarrierOther',                     '0x80000000')";

DefineEnum = "'OptRenderStateCacheFlag' : ('OptRenderStateCacheMsaaState',                  '0x00000001'),
                                          ('OptRenderStateCacheColorBlendState',            '0x00000002'),
                                          ('OptRenderStateCacheDepthStencilState',          '0x00000004'),
                                          ('OptRenderStateCacheInputAssemblyState',         '0x00000008'),
                                          ('OptRenderStateCacheTriangleRasterState',        '0x00000010'),
                                          ('OptRenderStateCacheStaticPointLineRasterState', '0x00000020'),
                                          ('OptRenderStateCacheStaticDepthBias',            '0x00000040'),
                                          ('OptRenderStateCacheStaticBlendConst',           '0x00000080'),
                                          ('OptRenderStateCacheStaticDepthBounds',          '0x00000100'),
                                          ('OptRenderStateCacheStaticViewport',             '0x00000200'),
                                          ('OptRenderStateCacheStaticScissorRect',          '0x00000400'),
                                          ('OptRenderStateCacheStaticSamplePattern',        '0x00000800'),
                                          ('OptRenderStateCacheStaticGraphicsWaveLimits',   '0x00001000'),
                                          ('OptRenderStateCacheStaticComputeWaveLimits',    '0x00002000'),
                                          ('OptRenderStateCacheStaticAnisoLodCompensation', '0x00004000')";

DefineEnum = "'FeatureEnableMode': ('FeatureDefault',             '0'),
                                   ('FeatureForceEnable',         '1'),
                                   ('FeatureForceDisable',        '2')";

DefineEnum = "'PreciseAnisoMode' : ('EnablePreciseAniso',        '0'),
                                   ('DisablePreciseAnisoAfOnly', '1'),
                                   ('DisablePreciseAnisoAll',    '2')";

DefineEnum = "'OptimizeCmdbufMode' : ('EnableOptimizeForRenderPassContinue',    '0'),
                                     ('EnableOptimizeCmdbuf',                   '1'),
                                     ('DisableOptimizeCmdbuf',                  '2')";

DefineEnum = "'TextureFilterOptimizationSettings' : ('TextureFilterOptimizationsDisabled',    '0'),
                                                    ('TextureFilterOptimizationsEnabled',     '1'),
                                                    ('TextureFilterOptimizationsAggressive',  '2')";

Node = "Render Passes"
{
    Leaf
    {
        SettingName = "RenderPassNewEnable";
        SettingType = "BOOL_STR";
        Description = "Use new render passes";
        VariableName = "renderPassNewEnable";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassLogEnable";
        SettingType = "BOOL_STR";
        Description = "Write a graph visualization of each created render pass in .dot format";
        VariableName = "renderPassLogEnable";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassLogDirectory";
        SettingType = "STRING_DIR";
        Description = "Relative directory where render pass graphs are placed.\r\n
                       Root directory is determined in device.\r\n
                       Each unique render pass is in a separate file within that directory.\r\n
                       The log name is based on a hash of the render pass's create info.\r\n";
        VariableName = "renderPassLogDirectory";
        VariableType = "char";
        VariableDefaultWin = "VulkanRenderPasses\\";
        VariableDefaultLnx = "amdpal/";
        StringLength = "512";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassLogFlags";
        SettingType = "HEX_STR";
        Description = "A bitmask of flags that control what kind of information is written to the render pass log:\r\n"
                      "0x00000001: Include render graph.\r\n";
                      "0x00000002: Include command list.\r\n";
                      "0x00000004: Include original VkSubpassDependency edges.\r\n"
                      "0x00000008: Include waits and signal event info.\r\n"
                      "0x00000010: Include cache/layout synchronization info.\r\n"

        VariableName = "renderPassLogFlags";
        VariableType = "uint32_t";
        VariableDefault = "0xffffffff";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassForceWaitIdle";
        SettingType = "BOOL_STR";
        Description = "If true, forces a full pipeline idle between each node rather than relying on GPU events.\r\n";
        VariableName    = "renderPassForceWaitIdle";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassForceCacheInputCoher";
        SettingType = "HEX_STR";
        Description = "If non-zero, the following input/output caches are always force-flushed between each node\r\n";
        VariableName    = "renderPassForceCacheInputCoher";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassForceCacheOutputCoher";
        SettingType = "HEX_STR";
        Description = "If non-zero, the following input/output caches are always force-flushed between each node\r\n";
        VariableName    = "renderPassForceCacheOutputCoher";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassAsyncEventEnable";
        SettingType = "BOOL_STR";
        Description = "Use asynchronous GPU events to wait between steps of a renderpass instance.";
        VariableName = "renderPassAsyncEventEnable";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }
}

Node = "Command Buffer Options"
{
    Leaf
    {
        SettingName = "CmdBufGpuEventMinAllocCount";
        SettingType = "UINT_STR";
        Description = "Minimum number of GPU events to allocate at once by the command buffer GPU event manager";
        VariableName = "cmdBufGpuEventMinAllocCount";
        VariableType = "uint32_t";
        VariableDefault = "128";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "UseSharedCmdAllocator";
        SettingType = "BOOL_STR";
        Description = "Use shared CmdAllocator for all command buffers";
        VariableName = "useSharedCmdAllocator";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorDataHeap";
        SettingType = "UINT_STR";
        Description = "The primary heap for the internal CmdAllocator for command data.\r\n
                       0: GpuHeapLocal\r\n
                       1: GpuHeapInvisible - This is invalid! Allocations must be mappable.\r\n
                       2: GpuHeapGartUswc\r\n
                       3: GpuHeapGartCacheable";
        VariableName = "cmdAllocatorDataHeap";
        VariableType = "Pal::GpuHeap";
        VariableDefault = "Pal::GpuHeapGartCacheable";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorDataAllocSize";
        SettingType = "UINT_STR";
        Description = "Size of allocation chunks used by CmdAllocators for command data";
        VariableName = "cmdAllocatorDataAllocSize";
        VariableType = "uint32_t";
        VariableDefault = "2097152";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorDataSubAllocSize";
        SettingType = "UINT_STR";
        Description = "Size of suballocations used by CmdAllocators for command data";
        VariableName = "cmdAllocatorDataSubAllocSize";
        VariableType = "uint32_t";
        VariableDefault = "65536";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorEmbeddedHeap";
        SettingType = "UINT_STR";
        Description = "The primary heap for the internal CmdAllocator for embedded data.\r\n
                       0: GpuHeapLocal\r\n
                       1: GpuHeapInvisible - This is invalid! Allocations must be mappable.\r\n
                       2: GpuHeapGartUswc\r\n
                       3: GpuHeapGartCacheable";
        VariableName = "cmdAllocatorEmbeddedHeap";
        VariableType = "Pal::GpuHeap";
        VariableDefault = "Pal::GpuHeapGartUswc";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorEmbeddedAllocSize";
        SettingType = "HEX_STR";
        VariableName = "cmdAllocatorEmbeddedAllocSize";
        Description = "Size of allocation chunks used by CmdAllocators for embedded data";
        VariableType = "uint32_t";
        VariableDefault = "0x20000";
    }

    Leaf
    {
        SettingName = "CmdAllocatorEmbeddedSubAllocSize";
        SettingType = "HEX_STR";
        VariableName = "cmdAllocatorEmbeddedSubAllocSize";
        Description = "Size of suballocations used by CmdAllocators for embedded data";
        VariableType = "uint32_t";
        VariableDefault = "0x4000";
    }

    Leaf
    {
        SettingName = "CmdAllocatorScratchHeap";
        SettingType = "UINT_STR";
        Description = "The primary heap for the internal CmdAllocator for GPU scratch memory.\r\n
                      Note: this field is ignored by PAL and will always be GpuHeapInvisible.\r\n
                       0: GpuHeapLocal\r\n
                       1: GpuHeapInvisible\r\n
                       2: GpuHeapGartUswc\r\n
                       3: GpuHeapGartCacheable";
        VariableName = "cmdAllocatorScratchHeap";
        VariableType = "Pal::GpuHeap";
        VariableDefault = "Pal::GpuHeapInvisible";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorScratchAllocSize";
        SettingType = "HEX_STR";
        VariableName = "cmdAllocatorScratchAllocSize";
        Description = "Size of allocation chunks used by CmdAllocators for GPU scratch memory";
        VariableType = "uint32_t";
        VariableDefault = "0x20000";
    }

    Leaf
    {
        SettingName = "CmdAllocatorScratchSubAllocSize";
        SettingType = "HEX_STR";
        VariableName = "cmdAllocatorScratchSubAllocSize";
        Description = "Size of suballocations used by CmdAllocators for GPU scratch memory";
        VariableType = "uint32_t";
        VariableDefault = "0x4000";
    }
}

Node = "Pipeline Options"
{
    Leaf
    {
        SettingName = "PipelineLinkTimeOptMode";
        SettingType = "UINT_STR";
        Description = "Controls how PAL's link-time pipeline optimizations are enabled:
                       \r\n0: Enabled unless VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT is set.
                       \r\n1: Optimizations always enabled.
                       \r\n2: Optimizations always disabled.";
        VariableName  = "pipelineLinkTimeOptMode";
        VariableType = "PipelineLinkTimeOptMode";
        VariableDefault = "PipelineLinkTimeOptApiControlled";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "PipelineFastCompileMode";
        SettingType = "UINT_STR";
        Description = "Controls how SC 'fast compile mode' (disable optimizations) is enabled:
                       \r\n0: 'Fast compile' disabled unless VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT is set.
                       \r\n1: 'Fast compile' always enabled (disables SC shader optimization).
                       \r\n2: 'Fast compile' always disabled (SC default optimizations enabled).";
        VariableName  = "pipelineFastCompileMode";
        VariableType = "PipelineFastCompileMode";
        VariableDefault = "PipelineFastCompileApiControlled";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "PipelineBinningMode";
        SettingType = "UINT_STR";
        Description = "Specifies whether to override binning setting for pipeline:
                       \r\n0: 'Default' follows the PBB global setting.
                       \r\n1: 'Disable' disables pipeline binning.
                       \r\n2: 'Enable' enables pipeline binning";
        VariableName  = "pipelineBinningMode";
        VariableType = "PipelineBinningMode";
        VariableDefault = "PipelineBinningModeDefault";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineUseProfileHashAsClientHash";
        SettingType     = "BOOL_STR";
        Description     = "If true, the profile hash (calculated exclusively from SPIRV + entry point) is used as PAL\r\n
                          client hash and will appear in e.g. GPUProfiler layer measurements.  Useful when writing and\r\n
                          updating pipeline profiles for applications.\r\n";

        VariableName       = "pipelineUseProfileHashAsClientHash";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineUseShaderHashAsProfileHash";
        SettingType     = "BOOL_STR";
        Description     = "If true, the shader hash (calcualte from SPIRV) is used as profile hash.\r\n";

        VariableName       = "pipelineUseShaderHashAsProfileHash";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineProfileRuntimeFile";
        SettingType     = "STRING";
        Description     = "Path to a JSON file that describes a shader app profile that is parsed at runtime.  This\r\n
                           setting only triggers on debug builds or builds made with the ICD_RUNTIME_APP_PROFILE=1\r\n
                           option.  This file has the same format as the JSON files used to build production shader\r\n
                           app profiles.";

        VariableName       = "pipelineProfileRuntimeFile";
        VariableType       = "char";
        VariableDefault    = "";
        StringLength       = "512";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineProfileDbgPrintProfileMatch";
        SettingType     = "BOOL_STR";
        Description     = "Prints a message to the debugger when a pipeline profile matches a pipeline.  Only valid\r\n
                           on debug builds or builds built with PAL_ENABLE_PRINTS_ASSERTS=1.";

        VariableName       = "pipelineProfileDbgPrintProfileMatch";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineProfileIgnoresAppProfile";
        SettingType     = "BOOL_STR";
        Description     = "If this is true, any production app profile-installed shader optimizations are ignored.";

        VariableName       = "pipelineProfileIgnoresAppProfile";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineProfileHaltOnParseFailure";
        SettingType     = "BOOL_STR";
        Description     = "If the driver fails to parse a runtime profile JSON file, it will assert and enter into an
                           infinite loop if this setting is TRUE.\r\n";

        VariableName       = "pipelineProfileHaltOnParseFailure";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }
}

Node = "Present"
{
    Leaf
    {
        SettingName = "UmdFramePacerControl";
        SettingType = "BOOL_STR";
        VariableName = "enableUmdFramePacer";
        Description = "Enable UMD frame pacer control.";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableFRTC";
        SettingType = "BOOL_STR";
        VariableName = "enableFrtc";
        Description = "Enable Frame Rate Target Control.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableTurboSync";
        SettingType = "BOOL_STR";
        VariableName = "enableTurboSync";
        Description = "Enable Turbo Sync control.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "FullscreenFrameMetadataSupport";
        SettingType = "BOOL_STR";
        VariableName = "fullScreenFrameMetadataSupport";
        Description = "Support Fullscreen Frame Metadata.";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }
}

Node = "SPIRV Options"
{
    Leaf
    {
        SettingName = "EnableLLPC";
        SettingType = "UINT_STR";
        VariableName = "enableLlpc";
        Description = "Use LLVM based pipeline compiler.\r\n
                       This option is valid only if marco ICD_BUILD_LLPC is defined. \r\n
                       and in LLVM compiler mode, all other SPIRV debug options are not valid now. \r\n
                       0 (LlpcModeScpcOnly)         - enable scpc only \r\n
                       1 (LlpcModeLlpcOnly)         - enable llpc only \r\n
                       2 (LlpcModeMixScpcInclusive) - enable llpc and scpc mix mode, use scpc for pipelines inside a specific range \r\n
                       3 (LlpcModeMixScpcExclusive) - enable llpc and scpc mix mode, use scpc for pipelines outside a specific range \r\n
                       4 (LlpcModeAutoFallback)     - enable llpc in default and fallback to scpc if llpc return errors";
                       5 (LlpcModeMixScpcHashList)  - enable llpc and scpc mix mode, use scpc for pipelines in hash list";
                       6 (LlpcModeMixLlpcHashList)  - enable llpc and scpc mix mode, use llpc for pipelines in hash list";
        VariableType = "uint32_t";
        VariableDefault = "1";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "LlpcMixModeHashCodeStart";
        SettingType = "HEX64_STR";
        VariableName = "llpcMixModeHashCodeStart";
        Description = "This option is valid when set EnableLLPC to 2 or 3. This option specify the start of a pipeline range, \r\n
                       When set EnableLLPC to 2, pipelines inside this range will be created by SCPC, \r\n
                       When set EnableLLPC to 3, pipelines outside this range will be created by SCPC.";
        VariableType = "uint64_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "LlpcMixModeHashCodeEnd";
        SettingType = "HEX64_STR";
        VariableName = "llpcMixModeHashCodeEnd";
        Description = "This option is valid when set EnableLLPC to 2 or 3. This option specify the start of a pipeline range, \r\n
                       When set EnableLLPC to 2, pipelines inside this range will be created by SCPC, \r\n
                       When set EnableLLPC to 3, pipelines outside this range will be created by SCPC.";
        VariableType = "uint64_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "LlpcMixModeHashListFileName";
        SettingType = "STRING";
        VariableName = "llpcMixModeHashListFileName";
        Description = "This option is valid when set EnableLLPC to 5 or 6. This option specify the pipeline list, \r\n
                       When set EnableLLPC to 5, pipelines in this list will be created by SCPC, \r\n
                       When set EnableLLPC to 6, pipelines outside the list will be created by SCPC.  \r\n
                       Each line is a hex string: e.g.: 0xb000zzyyxx.";
        VariableType = "char";
        StringLength = "256";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnablePipelineDump";
        SettingType = "BOOL_STR";
        VariableName = "enablePipelineDump";
        Description = "Enable pipeline dump, pipeline is stored with .pipe format.\r\n";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "PipelineDumpDir";
        SettingType = "STRING_DIR";
        VariableName = "pipelineDumpDir";
        Description = "Relative directory where pipeline info is dumped.\r\n
                       Root directory is determined in device.\r\n
                       Each unique pipeline is in a separate file within that directory.\r\n
                       The log name is based on a hash of the pipeline's create info and \r\n
                       which shader stages are active.\r\n";
        VariableType = "char";
        StringLength = "256";
        VariableDefaultWin = "SpvPipeline";
        VariableDefaultLnx = "spvPipeline";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableLog";
        SettingType = "UINT_STR";
        VariableName = "enableLog";
        Description = "Enable log general output and error message in LLPC and BIL.\r\n
                       0: Disable all logs\r\n
                       1: Enable output error message\r\n
                       2: Enable output general info\r\n
                       3: Enable output both general info and error message\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "LogFileName";
        SettingType = "STRING";
        VariableName = "logFileName";
        Description = "Filename of the log file in LLPC and BIL.\r\n
                       If the file name is empty, the message will be output to stdout.";
        VariableType = "char";
        StringLength = "256";
        VariableDefault = "spvLogInfo.txt";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableDebug";
        SettingType = "BOOL_STR";
        VariableName = "enableDebug";
        Description = "Enable output diagnostic info. This info may added to AMD IL or external debug log files.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DebugLogFileName";
        SettingType = "STRING";
        VariableName = "debugLogFileName";
        Description = "Filename of the file to log debug information. \r\n
                       If the file name is empty, the message will be output to stderr.";
        VariableType = "char";
        StringLength = "256";
        VariableDefault = "debugLogInfo.txt";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ShaderReplaceMode";
        SettingType = "UINT_STR";
        VariableName = "shaderReplaceMode";
        Description = "Enable shader replacement.\r\n
                       This option is valid only if LLPC path is enabled. \r\n
                       0 - Disable shader replacement (default)\r\n
                       1 - Enable shader hash based shader replacement, for any shader whose hash is AAA,\r\n
                           if there is a file named shader_0xAAA_replace.spv under ShaderReplacementDir, this file will be\r\n
                           used to replace the original shader.\r\n
                       2 - Enable shader hash plus pipeline hash filter based shader replacement, shader hash based shader replacement
                           will only be enabled for pipelines whose hash is in ShaderReplacementPipelineHashs.\r\n";
        VariableType = "ShaderReplaceMode";
        VariableDefault = "ShaderReplaceDisable";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ShaderReplaceDir";
        SettingType = "STRING_DIR";
        VariableName = "shaderReplaceDir";
        Description = "Relative directory where shader replacement files are stored.\r\n
                       Root directory is determined in device.\r\n";
        VariableType = "char";
        StringLength = "256";
        VariableDefaultWin = "ShaderReplace";
        VariableDefaultLnx = "ShaderReplace";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ShaderReplacePipelineHashes";
        SettingType = "STRING";
        VariableName = "shaderReplacePipelineHashes";
        Description = "Only valid if shaderReplaceMode is set to 2. This is a comma separated pipeline hash list.\r\n";
        VariableType = "char";
        StringLength = "512";
        VariableDefault = "";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableSpvPerfOptimal";
        SettingType = "BOOL_STR";
        VariableName = "enableSpvPerfOptimal";
        Description = "[BIL ONLY] Generate optimized IL codes for performance purpose.\r\n
                       This may break some precision rules and may not produce 100% conforming IL codes.\r\n
                       Therefore, the option should only be enabled via application profile.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableSpvValidation";
        SettingType = "BOOL_STR";
        VariableName = "enableSpvValidation";
        Description = "[BIL ONLY] Enable SPIR-V binary validation.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "UseILBranch";
        SettingType = "BOOL_STR";
        VariableName = "useIlBranch";
        Description = "[BIL ONLY] Uses AMD IL branch for SPIRV control flow operations.\r\n";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ZeroInitILRegs";
        SettingType = "BOOL_STR";
        VariableName = "zeroInitIlRegs";
        Description = "[BIL ONLY] Zero initialize AMD IL registers.\r\n";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "SkipUnsupportedOpCode";
        SettingType = "BOOL_STR";
        VariableName = "skipUnsupportedOpCode";
        Description = "[BIL ONLY] Skip unsupported SPIR-V instructions.\r\n";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "LlpcOptions";
        SettingType = "STRING";
        VariableName = "llpcOptions";
        Description = "[LLPC ONLY] LLPC general options. Max length of the option is 256.
                       \r\nfor example:
                       \r\nDisable Loop unroll: -pragma-unroll-threshold=1
                       \r\nEnable si-scheduler: -enable-si-scheduler
                       \r\nPlease see amdllpc -help or -help-hidden for detail";
        VariableType = "char";
        StringLength = "256";
        VariableDefault = "";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ShaderCacheMode";
        SettingType = "UINT_STR";
        Description = "Controls whether the Device shader cache should be used to try to avoid redundant\r\n
                       shader compiles
                       \r\n0: Shader Cache is disabled.
                       \r\n1: Shader Cache is enabled for runtime use only.
                       \r\n2: Shader Cache is enabled with on-disk file backing.
                       \r\n3: Shader Cache is forced on with on-disk file backing even for applications that specify pipeline caches.";
        VariableName  = "shaderCacheMode";
        VariableType = "ShaderCacheMode";
        VariableDefault = "ShaderCacheEnableRuntimeOnly";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "UsePalPipelineCaching";
        SettingType = "BOOL_STR";
        Description = "Controls whether the pipeline compiler enables Pal's archive-file based\r\n
                       caching for saving shader ELFs. (Default: FALSE)\r\n
                       Requires the following environment variables to be set:
                       \r\nAMD_ARCHIVE_DISK_CACHE_PATH: Path to where archive file is to be stored (required)
                       \r\nAMD_ARCHIVE_APP_PREFIX     : Fixed prefix string for generated archive file name (optional)";
        VariableName  = "usePalPipelineCaching";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "MarkPipelineCacheWithBuildTimestamp";
        SettingType = "BOOL_STR";
        Description = "Controles whether the pipline cache is tagged with the build timestamp.\r\n
                       This provides extra stability by forcing a cache rebuild for every new driver released. \r\n
                       May be useful to disable during rapid iteration. (Default: TRUE)";
        VariableName  = "markPipelineCacheWithBuildTimestamp";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "FilterPipelineDumpByType";
        SettingType = "HEX_STR";
        Description = "Filter which types of pipeline dump are disabled:\r\n
                        0x00 - Do not disable any pipeline type \r\n
                        0x01 - Disable pipeline dump for Cs pipelines \r\n
                        0x02 - Disable pipeline dump for NGG pipelines \r\n
                        0x04 - Disable pipeline dump for Gs pipelines \r\n
                        0x08 - Disable pipeline dump for Tess pipelines \r\n
                        0x10 - Disable pipeline dump for VsPs pipelines \r\n
                        \r\n
                        These options can be used to dump pipelines of a specific type. By default,\r\n
                        all the pipelines are logged.";
        VariableName = "filterPipelineDumpByType";
        VariableType = "uint32_t";
        VariableDefault = "PipelineDumpFilterNone";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "FilterPipelineDumpByHash";
        SettingType = "HEX64_STR";
        Description = "If non-zero, only dump the pipeline with this compiler hash.";
        VariableName = "filterPipelineDumpByHash";
        VariableType = "uint64_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DumpShadersSeparately";
        SettingType = "BOOL_STR";
        Description = "[SCPC only] If true, each shader in a pipeline will be dumped to a separate file.\r\n
                       Otherwise, the whole pipeline is placed in a single file.";
        VariableName = "dumpShadersSeparately";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DumpDuplicatePipelines";
        SettingType = "BOOL_STR";
        Description = "If true, duplicate pipelines will be dumped to a file with a numeric suffix attached\r\n
                       to the filename to distinguish each copy of the pipeline.";
        VariableName = "dumpDuplicatePipelines";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

}

Node = "Debugging"
{
    Leaf
    {
        SettingName = "DbgBarrierPostCmdEnable";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostCmdEnable";
        Description = "Triggers a CmdBarrier call after any command in the given mask.  The barrier behavior is\r\n
                       controlled by the other DbgBarrierPost* settings in this category.\r\n
                       \r\n
                       Requires VK_ENABLE_DEBUG_BARRIERS=1 to take effect\r\n
                       \r\n
                       0x00000001: Any non-indexed draw (including indirect)\r\n
                       0x00000002: Any indexed draw (including indirect)\r\n
                       0x00000004: Any indirect draw\r\n
                       0x00000008: Any direct dispatch\r\n
                       0x00000010: Any indirect dispatch\r\n
                       0x00000020: Any transfer copy involving a buffer\r\n
                       0x00000040: Any transfer copy involving an image\r\n
                       0x00000080: Any transfer copy involving a query pool\r\n
                       0x00000100: Any color clear operation (including render pass clears)\r\n
                       0x00000200: Any depth-stencil clear operation (including render pass clears)\r\n
                       0x00000400: Any resolve operation (including render pass resolves)\r\n
                       0x00000800: vkCmdBeginRenderPass\r\n
                       0x00001000: vkCmdNextSubpass\r\n
                       0x00002000: vkCmdEndRenderPass\r\n
                       0x00004000: vkCmdSetEvent or vkCmdResetEvent\r\n
                       0x00008000: vkCmdPipelineBarrier or vkCmdWaitEvents\r\n
                       0x00010000: vkCmdBeginQuery or vkCmdEndQuery\r\n
                       0x00020000: vkCmdResetQueryPool\r\n
                       0x00040000: vkCmdExecuteCommands\r\n
                       0x00080000: Start of the command buffer\r\n
                       0x00100000: End of the command buffer\r\n
                       0x00200000: vkCmdBindPipeline\r\n
                       0x00400000: vkCmdBindDescriptorSets or vkCmdPushConstants\r\n
                       0x00800000: vkCmdBindIndexBuffer or vkCmdBindVertexBuffers\r\n
                       0x01000000: vkCmdWriteTimestamp\r\n
                       0x02000000: Any vkCmdSet* which programs dynamic pipeline state\r\n
                       0x04000000: Any video operations\r\n
                       0x80000000: Any other command not listed above\r\n";

        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPostWaitPipePoint";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostWaitPipePoint";
        Description = "For post-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the\r\n
                       barrier will wait.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPostSignalPipePoint";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostSignalPipePoint";
        Description = "For post-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the\r\n
                       barrier is signaled.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPostCacheSrcMask";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostCacheSrcMask";
        Description = "For post-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags source\r\n
                       mask.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPostCacheDstMask";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostCacheDstMask";
        Description = "For post-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags destination\r\n
                       mask.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreCmdEnable";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreCmdEnable";
        Description = "Triggers a CmdBarrier call before any command in the given mask.  The barrier behavior is\r\n
                       controlled by the other DbgBarrierPre* settings in this category.\r\n
                       \r\n
                       Requires VK_ENABLE_DEBUG_BARRIERS=1 to take effect\r\n
                       \r\n
                       For further documentation, consult the corresponding DbgBarrierPost* command.\r\n";

        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreWaitPipePoint";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreWaitPipePoint";
        Description = "For pre-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the\r\n
                       barrier will wait.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreSignalPipePoint";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreSignalPipePoint";
        Description = "For pre-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the\r\n
                       barrier is signaled.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreCacheSrcMask";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreCacheSrcMask";
        Description = "For pre-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags source\r\n
                       mask.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreCacheDstMask";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreCacheDstMask";
        Description = "For pre-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags destination\r\n
                       mask.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }
}

Node = "General"
{
    Leaf
    {
        SettingName     = "VulkanOverlayEnable";
        SettingType     = "HEX_STR";
        Description     = "Enable specific channels of the Vulkan debug overlay through a bitmask.  Only takes effect\r\n
                           for drivers compiled with the .intdev target (VK_INTERNAL_DEVELOPER=1).  The recognized\r\n
                           channels are:\r\n
                           \r\n
                           0x00000001: OverlayPresentInfo - Information about presents\r\n
                           0x00000002: OverlayBarrierInfo - Information about barriers\r\n";

        VariableName    = "overlayEnable";
        VariableType    = "uint32_t";
        VariableDefault = "0";
    }

    Leaf
    {
        SettingName     = "VertexBufferTableInstanceRingSize";
        SettingType     = "UINT_STR";
        Description     = "Instanced vertex buffer table ring size.";
        VariableName    = "vbTableInstanceRingSize";
        VariableType    = "uint32_t";
        VariableDefault = "1024";
    }

    Leaf
    {
        SettingName     = "ResourceBarrierOptions";
        SettingType     = "HEX_STR";
        Description     = "Force command buffer based barrier queue usage.\r\n
                           0x0000 - DefaultResourceBarrier - Default barrier queues\r\n
                           0x4000 - CombinedAccessMask - Ignore Vulkan separate access mask rule\r\n
                           0x8000 - SkipDstCacheInv - Do not invalidate dest caches if src cache was not updated\r\n
                           0x2000 - PreferFlushOverInv - By default we invalidate input caches to accomodate the\r\n
                                    Vulkan separate access mask rule. When this is set we'll instead flush all\r\n
                                    output caches instead to achieve the same goal.\r\n
                                    Mutually exclusive with SkipDstCacheInv.\r\n
                                    May or may not be beneficial for certain applications.\r\n
                           0x0100 - Gfx6KeepShaderCoher - Keep shader domain always coherent on GFX6-GFX8 thus\r\n
                                    avoiding L2 cache flushes/invalidations in shader-to-shader barrier cases at\r\n
                                    the expense of always flushing/invalidating L1 caches.\r\n
                                    This does NOT violate the Vulkan separate access mask rule.\r\n
                                    This behavior is likely preferred on GFX6-GFX8.\r\n
                           0x0200 - Gfx6AvoidCpuMemoryCoher - Avoid CPU and memory domain coherency on GFX6-GFX8\r\n
                                    unless corresponding flags are explicitly requested to lower the number of L2\r\n
                                    cache flushes/invalidations.\r\n
                                    This does NOT violate the Vulkan separate access mask rule.\r\n
                                    This behavior may or may not be beneficial on GFX6-GFX8.\r\n
                           0x0400 - Gfx9KeepShaderCoher - Keep shader domain always coherent on GFX9+ thus\r\n
                                    avoiding L2 cache flushes/invalidations in shader-to-shader barrier cases at\r\n
                                    the expense of always flushing/invalidating L1 caches.\r\n
                                    This does NOT violate the Vulkan separate access mask rule.\r\n
                                    This behavior may not be beneficial on GFX9+.\r\n
                           0x0800 - Gfx9AvoidCpuMemoryCoher - Avoid CPU and memory domain coherency on GFX9+\r\n
                                    unless corresponding flags are explicitly requested to lower the number of L2\r\n
                                    cache flushes/invalidations.\r\n
                                    This does NOT violate the Vulkan separate access mask rule.\r\n
                                    This behavior is preferred on GFX9+ as all other accesses go through the L2.\r\n
                           Default of 0x8A00\r\n
                           \r\n
                           Scrambled Registry Key:\r\n
                           Default Value: SkipDstCacheInv | Gfx6AvoidCpuMemoryCoher | Gfx9AvoidCpuMemoryCoher";
        VariableName    = "resourceBarrierOptions";
        VariableType    = "uint32_t";
        VariableDefault = "0x8A00";
    }

    Leaf
    {
        SettingName     = "ExcessivePipelineCacheCountThreshold";
        SettingType     = "UINT_STR";
        Description     = "The number of pipeline cache count we treat as excessive and thus a smaller internal implementation is used for pipeline cache.\r\n";
        VariableName    = "excessivePipelineCacheCountThreshold";
        VariableType    = "uint32_t";
        VariableDefault = "256";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "EnumPreferredDeviceIndex";
        SettingType     = "UINT_STR";
        Description     = "If not UINT_MAX, this device index will always be returned as the first enumerated physical device.  Note that this index ordering is arbitrary and does not match the original ordering of PAL enumeration";
        VariableName    = "enumPreferredDeviceIndex";
        VariableType    = "uint32_t";
        VariableDefault = "0xffffffff";
    }

    Leaf
    {
        SettingName     = "RobustBufferAccess";
        SettingType     = "UINT_STR";
        Description     = "Force VkPhysicalDeviceFeatures::robustBufferAccess.\r\n
                           0 - Default, use appliation setting\r\n
                           1 - Force Enable\r\n
                           2 - Force Disable\r\n
                           Default Value: 0";
        VariableName    = "robustBufferAccess";
        VariableType    = "FeatureEnableMode";
        VariableDefault = "FeatureDefault";
    }

    Leaf
    {
        SettingName     = "LenientInstanceFuncQuery";
        SettingType     = "BOOL_STR";
        Description     = "Allows instance-level functions to be queried using vkGetDeviceProcAddr.\r\n";
        VariableName    = "lenientInstanceFuncQuery";
        VariableType    = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName     = "AppProfileDumpDir";
        SettingType     = "STRING";
        Description     = "Determines where the vkAppProfile.txt file will be written to. This file contains \r\n
                           the app profile enumeration index.\r\n";
        VariableName       = "appProfileDumpDir";
        VariableType       = "char";
        VariableDefault    = "";
        StringLength       = "512";
    }

    Leaf
    {
        SettingName     = "OptEnablePrt";
        SettingType     = "BOOL_STR";
        Description     = "Enable PRT feature in general. The defailed feature set is decided according to caps \r\n
                           reported by Pal. \r\n";
        VariableName    = "optEnablePrt";
        VariableType    = "bool";
        VariableDefault = "false";
    }
}

Node = "Memory"
{
    Leaf
    {
        SettingName     = "MemoryCustomDeviceAllocationCountLimit";
        SettingType     = "UINT_STR";
        Description     = "Custom device allocation count limitation, when larger than 0.\r\n";
        VariableName    = "memoryCustomDeviceAllocationCountLimit";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryBaseAddrAlignment";
        SettingType     = "HEX_STR";
        Description     = "All VkMemory memory objects will have the following the GPU VA base address alignment.\r\n";
        VariableName    = "memoryBaseAddrAlignment";
        VariableType    = "uint32_t";
        VariableDefault = "0x80000";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryBaseAddrAlignmentCpuVisibleWin32";
        SettingType     = "HEX_STR";
        Description     = "On 32-bit Windows builds, the following GPU VA base alignment is used for host-visible\r\n
                           memory types instead of MemoryBaseVaAlign.\r\n";
        VariableName    = "memoryBaseAddrAlignmentCpuVisibleWin32";
        VariableType    = "uint32_t";
        VariableDefault = "0x20000";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryEnableRemoteBackupHeap";
        SettingType     = "BOOL_STR";
        Description     = "If true, the remote (GART USWC) heap is enabled as a secondary heap for all VkMemory\r\n
                           objects created using a GPU-local preferred heap.\r\n";
        VariableName    = "memoryEnableRemoteBackupHeap";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryEnableLocalHeapTracking";
        SettingType     = "BOOL_STR";
        Description     = "If true, local memory allocated by the application is tracked per device and per heap. \r\n
                           If the size of a target heap is reached, VK_OUT_OF_DEVICE_MEMORY is returned.\r\n";
        VariableName    = "memoryEnableLocalHeapTracking";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityDefault";
        SettingType     = "HEX_STR";
        Description     = "Default priority of all VkMemory objects as two hex digits.  The first (most-significant)\r\n
                           digit defines the priority level, and the second digit defines the priority offset.\r\n
                           \r\n
                           Valid priority level values (Pal::GpuMemPriority) are:\r\n
                           \r\n
                           0: Unused\r\n
                           1: VeryLow\r\n
                           2: Low\r\n
                           3: Normal\r\n
                           4: High\r\n
                           5: VeryHigh\r\n
                           \r\n
                           Valid priority offset values (Pal::GpuMemPriorityOffset) are:\r\n
                           0: Offset0 (same as base level)\r\n
                           1: Offset1\r\n
                           2: Offset2\r\n
                           3: Offset3\r\n
                           4: Offset4\r\n
                           5: Offset5\r\n
                           6: Offset6\r\n
                           7: Offset7\r\n";

        VariableName    = "memoryPriorityDefault";
        VariableType    = "uint32_t";
        VariableDefault = "0x30";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageAny";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one image.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageAny";
        VariableType    = "uint32_t";
        VariableDefault = "0x30";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageShaderRead";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one image shader-readable image.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageShaderRead";
        VariableType    = "uint32_t";
        VariableDefault = "0x30";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageShaderWrite";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one shader-writable (storage) image.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageShaderWrite";
        VariableType    = "uint32_t";
        VariableDefault = "0x30";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageColorTarget";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one image that can be a color target.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageColorTarget";
        VariableType    = "uint32_t";
        VariableDefault = "0x40";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageDepthStencil";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one image that can be a depth-stencil.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageDepthStencil";
        VariableType    = "uint32_t";
        VariableDefault = "0x40";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DisableDeviceOnlyMemoryTypeWithoutHeap";
        SettingType     = "HEX_STR";
        Description     = "Remove non-host visible, device local memory type when there's no GPU invisible heap/APUs.\r\n
                           \r\n
                           If the GPU invisible memory heap does not exist, we don't expose it.\r\n
                           However, we still support device-only memory that simply comes from\r\n
                           the GPU local heap unless this setting is true.\r\n";

        VariableName    = "disableDeviceOnlyMemoryTypeWithoutHeap";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "TransferGranularityUniversalOverride";
        SettingType     = "HEX_STR";
        Description     = "Override reported minImageTransferGranularity field for graphics queue families.  This\r\n
                           is encoded as a hex string of the form 0xb000zzyyxx, where 'xx', 'yy', and 'zz' are the\r\n
                           reported transfer granularities in the X, Y and Z extents respectively, and 'b' is\r\n
                           a control flag: if 'b' is non-zero, this override is applies; otherwise the standard\r\n
                           transfer granularity is used.\r\n";
        VariableName    = "transferGranularityUniversalOverride";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "TransferGranularityComputeOverride";
        SettingType     = "HEX_STR";
        Description     = "Override reported minImageTransferGranularity field for compute queue families.  For how\r\n
                          this value is interpreted by the driver, see the description for\r\n
                          TransferGranularityUniversalOverride.\r\n";
        VariableName    = "transferGranularityComputeOverride";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "TransferGranularityDmaOverride";
        SettingType     = "HEX_STR";
        Description     = "Override reported minImageTransferGranularity field for DMA (i.e. SDMA) queue families.\r\n
                          For how this value is interpreted by the driver, see the description for\r\n
                          TransferGranularityUniversalOverride.\r\n";
        VariableName    = "transferGranularityDmaOverride";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }
}

Node = "Optimization"
{
    Leaf
    {
        SettingName     = "ForceAppProfileEnable";
        SettingType     = "BOOL_STR";
        Description     = "Forces a particular AppProfile value.  The profile selected is the value of ForceAppProfileValue.\r\n";
        VariableName    = "forceAppProfileEnable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "ForceAppProfileValue";
        SettingType     = "UINT_STR";
        Description     = "Forces a particular AppProfile value.  This value is the integer value of the AppProfile enum.  Ignored unless ForceAppProfileEnable is true.\r\n";
        VariableName    = "forceAppProfileValue";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PreciseAnisoMode";
        SettingType     = "UINT_STR";
        Description     = "PreciseAnisoMode denotes whether preciseAniso will be enabled:\r\n
                          0(EnablePreciseAniso):        precisAniso will be enabled. Highest image quality.\r\n
                          1(DisablePreciseAnisoAfOnly): precisAniso will be disabled only for anisotropic samplers.\r\n
                          2(DisablePreciseAnisoAll):    precisAniso will be disabled for all samplers. Lowest image quality.\r\n";
        VariableName    = "preciseAnisoMode";
        VariableType    = "PreciseAnisoMode";
        VariableDefault = "DisablePreciseAnisoAfOnly";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "UseAnisoThreshold";
        SettingType     = "BOOL_STR";
        Description     = "Supply the threshold value for anisotropic filtering (DisablePreciseAniso needs to be true also)\r\n";
        VariableName    = "useAnisoThreshold";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "AnisoThreshold";
        SettingType     = "FLOAT_STR";
        Description     = "The threshold value for anisotropic filtering (DisablePreciseAniso & UseAnisoThreshold need to be true also)\r\nDefault value (0.25) preserves the Pal behaviour";
        VariableName    = "anisoThreshold";
        VariableType    = "float";
        VariableDefault = "0.25";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "UseFlipHint";
        SettingType     = "BOOL_STR";
        Description     = "Use flip hint for swapchain. Linux Only. The X Server make the final decision whether to go async flip.";
        VariableName    = "useFlipHint";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "BackgroundFullscreenPresent";
        SettingType     = "HEX_STR";
        Description     = "Force fullscreen exclusive presents when detected safe.  The following combination of\r\n
                           flags control whether this feature is enabled for a particular OS + swapchain combination:\r\n
                           \r\n
                           0x0000001 - Win7-8 + VK_PRESENT_MODE_IMMEDIATE_KHR\r\n
                           0x0000002 - Win7-8 + VK_PRESENT_MODE_MAILBOX_KHR\r\n
                           0x0000004 - Win7-8 + VK_PRESENT_MODE_FIFO_KHR\r\n
                           0x0000008 - Win7-8 + VK_PRESENT_MODE_FIFO_RELAXED_KHR\r\n
                           0x0000010 - Win10  + VK_PRESENT_MODE_IMMEDIATE_KHR\r\n
                           0x0000020 - Win10  + VK_PRESENT_MODE_MAILBOX_KHR\r\n
                           0x0000040 - Win10  + VK_PRESENT_MODE_FIFO_KHR\r\n
                           0x0000080 - Win10  + VK_PRESENT_MODE_FIFO_RELAXED_KHR\r\n
                           0x0000100 - Win7-8 + Multi-GPU\r\n
                           0x0000200 - Win10  + Multi GPU\r\n";
        VariableName    = "backgroundFullscreenPresent";
        VariableType    = "uint32_t";
        VariableDefault = "0x3ff";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "BackgroundFullscreenFailureDisableCount";
        SettingType     = "BOOL_STR";
        Description     = "Fullscreen presents may fail due to unexpected errors, although these cases are rare.\r\n
                           Failing a fullscreen present and reattempting to acquire exclusive access causes dropped\r\n
                           frames and screen flickering.  This is a fail-safe setting that permanently disables the\r\n
                           the fullscreen present logic after the given number of consecutive unexpected failures.\r\n";
        VariableName    = "backgroundFullscreenFailureDisableCount";
        VariableType    = "uint32_t";
        VariableDefault = "2";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "BackgroundFullscreenSuccessResetCount";
        SettingType     = "BOOL_STR";
        Description     = "Reset the failure count only after this many consecutive successful fullscreen presents.\r\n
                           A large value for this setting is used to guarantee that we are consistently presenting\r\n
                           in fullscreen instead of rapidly ping-ponging between fullscreen and windowed presents.\r\n";
        VariableName    = "backgroundFullscreenSuccessResetCount";
        VariableType    = "uint32_t";
        VariableDefault = "64";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "BackgroundFullscreenIgnorePresentErrors";
        SettingType     = "BOOL_STR";
        Description     = "When forcing fullscreen presents, this flag will ignore unexpected errors on any failed\r\n
                           present.\r\n";
        VariableName    = "backgroundFullscreenIgnorePresentErrors";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "ImageTilingOptMode";
        SettingType = "UINT_STR";
        Description = "Hints to PAL to select the appropriate tiling mode for an optimization target.\r\n
                       0: Balanced\r\n
                       1: OptForSpace\r\n
                       2: OptForSpeed";
        VariableName = "imageTilingOptMode";
        VariableType = "Pal::TilingOptMode";
        VariableDefault = "Pal::TilingOptMode::Balanced";
        SettingScope = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "ImageTilingPreference";
        SettingType = "UINT_STR";
        Description = "Hints to pal to identify a preference for how this image is organized.\r\n
                       0: Default\r\n
                       1: Standard\r\n
                       2: XMajor\r\n
                       3: YMajor\r\n
                       4: Interleaved";
        VariableName = "imageTilingPreference";
        VariableType = "Pal::ImageTilingPattern";
        VariableDefault = "Pal::ImageTilingPattern::Default";
        SettingScope = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "EnableFmaskBasedMsaaRead";
        SettingType = "BOOL_STR";
        Description = "Enable FMASK based MSAA texture reads.\r\n";
        VariableName = "enableFmaskBasedMsaaRead";
        VariableType = "bool";
        VariableDefault = "true";
    }

    Leaf
    {
        SettingName     = "TransferSrcUsageAsShaderReadMask";
        SettingType     = "HEX_STR";
        Description     = "For image created with usage of transfer src, add shader_read in PAL usage if VkImageUsageFlagBits in this mask is set.\r\n";
        VariableName    = "optImgMaskToApplyShaderReadUsageForTransferSrc";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "TransferDstUsageAsShaderWriteMask";
        SettingType     = "HEX_STR";
        Description     = "For image created with usage of transfer dst, add shader_write in PAL usage if VkImageUsageFlagBits in this mask is set.\r\n";
        VariableName    = "optImgMaskToApplyShaderWriteUsageForTransferDst";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "OnlyEnableFP16ForGfx9Plus";
        SettingType     = "BOOL_STR";
        Description     = "Enable extension AMD_GPU_SHADER_HALF_FLOAT and AMD_GPU_SHADER_INT16 only on ASIC >= gfx9.\r\n";
        VariableName    = "optOnlyEnableFP16ForGfx9Plus";
        VariableType    = "bool";
        VariableDefault = "true";
    }

    Leaf
    {
        SettingName     = "ColorTargetUsageDoesNotContainResolveLayout";
        SettingType     = "BOOL_STR";
        Description     = "If set, an image with color target usage bit does not implicitly allow to be in resolve_src or resolve_dst layout. \r\n";
        VariableName    = "optColorTargetUsageDoesNotContainResolveLayout";
        VariableType    = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName     = "RenderStateCacheEnable";
        SettingType     = "HEX_STR";
        Description     = "This bitmask denotes which subset of pipeline render state is cached\r\n
                           at the device-level.  Caching render state enables more efficient redundancy checking when\r\n
                           recording command buffers.  This redundancy checking is mainly limited to pipeline state\r\n
                           that is either invisible to the API (e.g. certain PAL objects) or state that the application\r\n
                           has marked in the pipeline as non-dynamic, meaning its values are programmed during pipeline\r\n
                           bind.\r\n
                           \r\n
                           The following values control for which kinds of state this redundancy checking is enabled:\r\n
                           \r\n
                           0x00000001 - PAL MSAA state objects (all graphics pipelines)\r\n
                           0x00000002 - PAL color blend state objects (all graphics pipelines)\r\n
                           0x00000004 - PAL depth stencil state objects (all graphics pipelines)\r\n
                           0x00000008 - PAL input assembly state params (all graphics pipelines)\r\n
                           0x00000010 - Triangle raster state params (part of every graphics pipeline)\r\n
                           0x00000020 - Point line raster state (only when marked static)\r\n
                           0x00000040 - Depth bias state (only when marked static)\r\n
                           0x00000080 - Blend const state (only when marked static)\r\n
                           0x00000100 - Depth bounds state (only when marked static)\r\n
                           0x00000200 - Viewport state (only when marked static)\r\n
                           0x00000400 - Scissor rect state (only when marked static)";

        VariableName    = "optRenderStateCacheEnable";
        VariableType    = "uint32_t";
        VariableDefault = "0xffffffff";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "IgnoreMutableFlag";
        SettingType     = "BOOL_STR";
        Description     = "If set, the MUTABLE flag on image is ignored\r\n";
        VariableName    = "ignoreMutableFlag";
        VariableType    = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName     = "OptimizeCmdbufMode";
        SettingType     = "UINT_STR";
        Description     = "OptimizeCmdbufMode denotes whether pm4 optimizations will be enabled:\r\n
                          0(EnableOptimizeForRenderPassContinue):  optimizeCmdbuf will be enabled only for render pass continue.\r\n
                          1(EnableOptimizeCmdbuf):                 optimizeCmdbuf will be always enabled .\r\n
                          2(DisableOptimizeCmdbuf):                optimizeCmdbuf will be disabled.\r\n";
        VariableName    = "optimizeCmdbufMode";
        VariableType    = "OptimizeCmdbufMode";
        VariableDefault = "DisableOptimizeCmdbuf";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PrefetchShaders";
        SettingType     = "BOOL_STR";
        Description     = "If set, shaders are prefetched to warm L2 shader cache.\r\n";
        VariableName    = "prefetchShaders";
        VariableType    = "bool";
        VariableDefault = "false";
    }
}

Node = "Developer Mode"
{
    Leaf
    {
        SettingName     = "DevModeShaderIsaDbEnable";
        SettingType     = "BOOL_STR";
        Description     = "This controls whether RGP traces will include shader code of created pipelines.\r\n";
        VariableName    = "devModeShaderIsaDbEnable";
        VariableType    = "bool";
        VariableDefault = "true";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeQueueTimingEnable";
        SettingType     = "BOOL_STR";
        Description     = "This controls whether queue operations are timed during RGP traces.\r\n";
        VariableName    = "devModeQueueTimingEnable";
        VariableType    = "bool";
        VariableDefault = "true";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSemaphoreQueueTimingEnable";
        SettingType     = "BOOL_STR";
        Description     = "This controls if the legacy timed queue semaphores are to be used on\r\n
                           Windows instead of the ETW client. This parameter does not affect Linux.\r\n";
        VariableName    = "devModeSemaphoreQueueTimingEnable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkerEnable";
        SettingType     = "HEX_STR";
        Description     = "This controls what kind of SQTT instrumentation marker data is outputted\r\n
                           from the driver.  Note that this only fine-tunes instrumentation: the\r\n
                           master toggle for SQTT is always whether developer mode is enabled.\r\n
                           \r\n
                           General SQTT data (event, wave, instruction) is also generated independent\r\n
                           of this setting if SQTT is enabled.\r\n
                           \r\n
                           This setting can have a combination of the following values:\r\n
                           \r\n
                           0x0001 - Enable command buffer start instrumentation marker\r\n
                           0x0002 - Enable command buffer end instrumentation marker\r\n
                           0x0004 - Enable per-draw/dispatch event instrumentation markers\r\n
                           0x0008 - Enable barrier instrumentation markers\r\n
                           0x0010 - Enable general API (per entry point call) instrunmentation markers\r\n
                           0x0020 - Enable user event (app string) markers\r\n
                           0x0040 - Enable dispatch events with thread dimensions\r\n
                           0x0080 - Write bound shader hashes as user event markers (requires VK_INTERNAL_DEVELOPER)\r\n";

        VariableName    = "devModeSqttMarkerEnable";
        VariableType    = "uint32_t";
        VariableDefault = "0x6f";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttForceDisable";
        SettingType     = "BOOL_STR";
        Description     = "If true, SQTT support is disabled and all RGP traces will automatically fail.";

        VariableName    = "devModeSqttForceDisable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttWaitIdle";
        SettingType     = "BOOL_STR";
        Description     = "If true, a CPU device wait idle is executed prior to starting and\r\n
                           ending a trace.  PLEASE NOTE: This is currently not thread safe\r\n
                           and may result in crashes.  It is only included as a debugging\r\n
                           option.";

        VariableName    = "devModeSqttWaitIdle";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName     = "DevModeSqttFlushAllQueues";
        SettingType     = "BOOL_STR";
        Description     = "If true, inserts a full pipeline flush into all hardware queues\r\n
                           at the beginning of the last preparation frame in an RGP trace.";
        VariableName    = "devModeSqttFlushAllQueues";
        VariableType    = "bool";
        VariableDefault = "true";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttGpuMemoryLimit";
        SettingType     = "UINT_STR";
        Description     = "Maximum amount of data in bytes to capture per trace.  A trace will cover a span of commands\r\n
                           based on the GpuProfilerGranularity setting.  Defaults to 0, which means auto-calculate the\r\n
                           size based on GPU characteristics.  Current HW requires the size be aligned to 0x1000 bytes.";

        VariableName    = "devModeSqttGpuMemoryLimit";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttFrameCount";
        SettingType     = "UINT_STR";
        Description     = "Number of frames (present calls) to trace SQTT.";

        VariableName    = "devModeSqttFrameCount";
        VariableType    = "uint32_t";
        VariableDefault = "1";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttInternalUserEventPrefix";
        SettingType     = "STRING";
        Description     = "Any driver-generated user event markers will have this string as its prefix.";

        VariableName    = "devModeSqttInternalUserEventPrefix";
        VariableType    = "char";
        VariableDefault = "[AMD] ";
        StringLength    = "512";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkRenderPasses";
        SettingType     = "BOOL_STR";
        Description     = "If true, driver will insert user event strings of renderpass instances into RGP traces.\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n";

        VariableName    = "devModeSqttMarkRenderPasses";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkPipelineBinds";
        SettingType     = "BOOL_STR";
        Description     = "If true, driver will insert user event strings when pipelines are bound (including shader hashes).\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n";

        VariableName    = "devModeSqttMarkPipelineBinds";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkTargetBinds";
        SettingType     = "BOOL_STR";
        Description     = "If true, driver will insert user event strings when color/depth targets are bound.\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n";

        VariableName    = "devModeSqttMarkTargetBinds";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkPipelineBarriers";
        SettingType     = "BOOL_STR";
        Description     = "If true, driver will insert user event strings when pipeline barriers happen.\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n";

        VariableName    = "devModeSqttMarkPipelineBarriers";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttObjectMetaData";
        SettingType     = "HEX64_STR";
        Description     = "Track metadata for object types (each bit in the mask corresponds with enum value of VkDebugReportObjectTypeEXT).  Set to all f's to track all types.\r\n
                           Setting this will cause any debug names to be included with any of the other internal markings such as pipeline binds.\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n
                           \r\n
                           WARNING: Will likely interfere with multithreaded command buffer recording concurrency.\r\n";

        VariableName    = "devModeSqttTrackObjectMetaData";
        VariableType    = "uint64_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttTraceBeginEndTagEnable";
        SettingType     = "BOOL_STR";
        Description     = "If TRUE, DevModeSqttTrace[Begin|End]TagValues are used to override trace parameter
                           begin/end command buffer debug object tag values.  This is mainly used for debugging.\r\n";

        VariableName    = "devModeSqttTraceBeginEndTagEnable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttTraceBeginTagValue";
        SettingType     = "HEX64_STR";
        Description     = "Custom command buffer debug object tag value signifying virtual frame start.  Requires
                           DevModeSqttTraceBeginEndTagEnable.\r\n";

        VariableName    = "devModeSqttTraceBeginTagValue";
        VariableType    = "uint64_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttTraceEndTagValue";
        SettingType     = "HEX64_STR";
        Description     = "Custom command buffer debug object tag value signifying virtual frame end.  Requires
                           DevModeSqttTraceBeginEndTagEnable.\r\n";

        VariableName    = "devModeSqttTraceEndTagValue";
        VariableType    = "uint64_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttForceBlockOnTraceEnd";
        SettingType     = "BOOL_STR";
        Description     = "If TRUE, the driver will block immediately after ending a trace to wait for results to
                           complete rather than asynchronously checking for completion during frame boundaries.";

        VariableName    = "devModeSqttForceBlockOnTraceEnd";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttPrepareFrameCount";
        SettingType     = "HEX_STR";
        Description     = "If non-default, this value will override the trace parameter prepare frame count, which is
                           the number of lead frames prior to enabling SQTT that include only queue timing.";

        VariableName    = "devModeSqttPrepareFrameCount";
        VariableType    = "uint32_t";
        VariableDefault = "0xffffffff";
        SettingScope    = "PrivateDriverKey";
    }
}

Node = "Chill"
{
    Leaf
    {
        SettingName = "AllowChill";
        SettingType = "BOOL_STR";
        Description = "Allow chill to run. Chill is a user interaction dependent FPS limiter, \r\n
                       used for power saving.\r\n";
        VariableName = "allowChill";
        VariableType = "bool";
        VariableDefault = "true";
    }
    Leaf
    {
        SettingName = "Chill_ProfileEnable";
        SettingType = "BOOL_STR";
        Description = "If per-app chill profile settings is enabled.\r\n";
        VariableName = "chillProfileEnable";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_ChillLevel";
        SettingType = "HEX_STR";
        Description = "Chill level setting, default is medium:\r\n
                       0x0 - disable,\r\n
                       0x1 - subtle,\r\n
                       0x2 - medium,\r\n
                       0x3 - full,\r\n";
        VariableName = "chillLevel";
        VariableType = "uint32_t";
        VariableDefault = "IcdChillLevelMedium";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_MinFramerate";
        SettingType = "UINT_STR";
        Description = "Min chill frame rate; valid range is 30-300fps.";
        VariableName = "chillMinFrameRate";
        VariableType = "uint32_t";
        VariableDefault = "70";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_MaxFramerate";
        SettingType = "UINT_STR";
        Description = "Max chill frame rate; valid range is 30-300fps.";
        VariableName = "chillMaxFrameRate";
        VariableType = "uint32_t";
        VariableDefault = "144";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_LoadingScreenDrawsThresh";
        SettingType = "UINT_STR";
        Description = "The threshold number of draw calls per frame used to distinguish \r\n
                       between loading screens and gameplay.\r\n";
        VariableName = "chillLoadingScreenDrawsThresh";
        VariableType = "uint32_t";
        VariableDefault = "150";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_IgnoreBaseDriverRestrictions";
        SettingType = "BOOL_STR";
        Description = "When true, we will not disable chill based on KMD workstation flag \r\n
                       or Big Software version.\r\n";
        VariableName = "chillIgnoreBaseDriverRestrictions";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }
}

Node = "Shader Tuning"
{
    Leaf
    {
        SettingName = "OverrideShaderParams";
        SettingType = "BOOL_STR";
        Description = "Indicate that shader parameter override is enabled - mainly used for automation";
        VariableName = "overrideShaderParams";
        VariableType = "bool";
        VariableDefault = "false";
    }
    Leaf
    {
        SettingName = "OverrideShaderHashUpper";
        SettingType = "HEX64_STR";
        Description = "Upper 64-bits of the shader hash of shader for which wave parameters are to be overridden";
        VariableName = "overrideShaderHashUpper";
        VariableType = "uint64_t";
        VariableDefault = "0x0";
    }
    Leaf
    {
        SettingName = "OverrideShaderHashLower";
        SettingType = "HEX64_STR";
        Description = "Lower 64-bits of the shader hash of shader for which wave parameters are to be overridden";
        VariableName = "overrideShaderHashLower";
        VariableType = "uint64_t";
        VariableDefault = "0x0";
    }
    Leaf
    {
        SettingName = "OverrideShaderStage";
        SettingType = "UINT_STR";
        Description = "Shader stage for which wave parameters are to be overriden.\r\n
                       0 - Vertex Shader\r\n
                       1 - Tessellation Control Shader\r\n
                       2 - Tessellation Evaluation Shader\r\n
                       3 - Geometry Shader\r\n
                       4 - Fragment Shader\r\n
                       5 - Compute Shader\r\n";
        VariableName = "overrideShaderStage";
        VariableType = "uint32_t";
        VariableDefault = "4";
    }
    Leaf
    {
        SettingName = "OverrideNumVGPRsAvailable";
        SettingType = "UINT_STR";
        Description = "Override number of available VGPRs for the shader specified by overrideShaderCrcUpper/Lower";
        VariableName = "overrideNumVGPRsAvailable";
        VariableType = "uint32_t";
        VariableDefault = "0";
    }
    Leaf
    {
        SettingName = "OverrideWavesPerCu";
        SettingType = "UINT_STR";
        Description = "Override number of waves per CU for the shader specified by overrideShaderCrcUpper/Lower";
        VariableName = "overrideWavesPerCu";
        VariableType = "uint32_t";
        VariableDefault = "0";
    }
    Leaf
    {
        SettingName = "OverrideUserDataSpillThreshold";
        SettingType = "UINT_STR";
        Description = "Force PAL to spill user data registers to memory for the shader specified by overrideShaderCrcUpper/Lower";
        VariableName = "overrideUserDataSpillThreshold";
        VariableType = "bool";
        VariableDefault = "false";
    }
    Leaf
    {
        SettingName = "OverrideMaxLdsSpillDwords";
        SettingType = "UINT_STR";
        Description = "Set the max LDS spill size in DWORDs for the shader specified by overrideShaderCrcUpper/Lower";
        VariableName = "overrideMaxLdsSpillDwords";
        VariableType = "uint32_t";
        VariableDefault = "0";
    }
    Leaf
    {
        SettingName = "OverrideCsTgPerCu";
        SettingType = "UINT_STR";
        Description = "Set the thread-group per CU limit for compute shaders.";
        VariableName = "overrideCsTgPerCu";
        VariableType = "uint32_t";
        VariableDefault = "0";
    }
    Leaf
    {
        SettingName = "OverrideUsePbbPerCrc";
        SettingType = "HEX_STR";
        Description = "Set option to disable PBB for shader specified by OverrideShaderCrcUpper and\r\n
                       OverrideShaderCrcLower\r\n
                       0 - PipelineBinningModeDefault - Follow the behavior of the PipelineBinningMode setting\r\n
                       1 - PipelineBinningModeDisable - Force PBB off for shader\r\n
                       2 - PipelineBinningModeEnable  - Force PBB on for shader\r\n";
        VariableName = "overrideUsePbbPerCrc";
        VariableType = "PipelineBinningMode";
        VariableDefault = "PipelineBinningModeDefault";
    }
    Leaf
    {
        SettingName = "OverrideAllowReZ";
        SettingType = "BOOL_STR";
        Description = "Override allowReZ for the shader specified by OverrideShaderHashUpper/Lower.";
        VariableName = "overrideAllowReZ";
        VariableType = "bool";
        VariableDefault = "false";
    }
}

Node = "Public CCC Options"
{
    Leaf
    {
        SettingType = "UINT_STR";
        Description = "Specifies the GPU ID (composed of PCI info).";
        VariableName = "appGpuID";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PublicCatalystKey";
    }
    Leaf
    {
        SettingType = "UINT_STR";
        Description = "Controls texture filtering optimizations exposed by CCC.";
        VariableName = "vulkanTexFilterQuality";
        VariableType = "TextureFilterOptimizationSettings";
        VariableDefault = "TextureFilterOptimizationsEnabled";
        SettingScope = "PublicCatalystKey";
    }
}
