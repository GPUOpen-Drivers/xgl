/*
 ***********************************************************************************************************************
 *
 *  Copyright (c) 2013-2019 Advanced Micro Devices, Inc. All Rights Reserved.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 **********************************************************************************************************************/

DefineEnum = "'BGFSEnableFlags' : ('BGFSEnableWddm1Immediate',   '0x0001'),
                                  ('BGFSEnableWddm1Mailbox',     '0x0002'),
                                  ('BGFSEnableWddm1Fifo',        '0x0004'),
                                  ('BGFSEnableWddm1FifoRelaxed', '0x0008'),
                                  ('BGFSEnableWddm2Immediate',   '0x0010'),
                                  ('BGFSEnableWddm2Mailbox',     '0x0020'),
                                  ('BGFSEnableWddm2Fifo',        '0x0040'),
                                  ('BGFSEnableWddm2FifoRelaxed', '0x0080'),
                                  ('BGFSEnableWddm1MultiGpu',    '0x0100'),
                                  ('BGFSEnableWddm2MultiGpu',    '0x0200');

DefineEnum = "'DevModeSqttMarkerEnableFlags' : ('DevModeSqttMarkerEnableCbStart',         '0x0001'),
                                               ('DevModeSqttMarkerEnableCbEnd',           '0x0002'),
                                               ('DevModeSqttMarkerEnableEvent',           '0x0004'),
                                               ('DevModeSqttMarkerEnableBarrier',         '0x0008'),
                                               ('DevModeSqttMarkerEnableGeneralApi',      '0x0010'),
                                               ('DevModeSqttMarkerEnableUserEvent',       '0x0020'),
                                               ('DevModeSqttMarkerEnableEventWithDims',   '0x0040'),
                                               ('DevModeSqttMarkerEnablePipelineBind',    '0x0100');

DefineEnum = "'PipelineFastCompileMode' : ('PipelineFastCompileApiControlled',   '0'),
                                          ('PipelineFastCompileAlwaysFast',      '1'),
                                          ('PipelineFastCompileAlwaysOptimized', '2'),
                                          ('PipelineFastCompileAlwaysFastWithOptimized', '3'),";"

DefineEnum = "'PipelineBinningMode' : ('PipelineBinningModeDefault',  '0'),
                                      ('PipelineBinningModeDisable',  '1'),
                                      ('PipelineBinningModeEnable',   '2'),";"

DefineEnum = "'PipelineLinkTimeOptMode' : ('PipelineLinkTimeOptApiControlled',  '0'),
                                          ('PipelineLinkTimeOptAlwaysEnabled',  '1'),
                                          ('PipelineLinkTimeOptAlwaysDisabled', '2')";"

DefineEnum = "'IcdChillLevelMode' :('IcdChillLevelDisable', '0'),
                                   ('IcdChillLevelSubtle',  '1'),
                                   ('IcdChillLevelMedium',  '2'),
                                   ('IcdChillLevelFull',    '3')";

DefineEnum = "'ShaderReplaceMode': ('ShaderReplaceDisable',            '0'),
                                   ('ShaderReplaceShaderHash',         '1'),
                                   ('ShaderReplaceShaderPipelineHash', '2'),
                                   ('ShaderReplacePipelineBinaryHash', '3'),
                                   ('ShaderReplaceShaderISA',          '4')";

DefineEnum = "'ShaderCacheMode': ('ShaderCacheDisable',                  '0'),
                                 ('ShaderCacheEnableRuntimeOnly',        '1'),
                                 ('ShaderCacheEnableOnDisk',             '2'),
                                 ('ShaderCacheForceInternalCacheOnDisk', '3')";

DefineEnum = "'PipelineDumpFilters' : ('PipelineDumpFilterNone',        '0x00')
                                      ('PipelineDumpFilterCs',          '0x01'),
                                      ('PipelineDumpFilterNgg',         '0x02'),
                                      ('PipelineDumpFilterGs',          '0x04'),
                                      ('PipelineDumpFilterTess',        '0x08'),
                                      ('PipelineDumpFilterVsPs',        '0x10')";

DefineEnum = "'ResourceBarrierOptions' :('DefaultResourceBarrier',         '0x0000'),
                                        ('CombinedAccessMasks',            '0x4000'),
                                        ('SkipDstCacheInv',                '0x8000'),
                                        ('PreferFlushOverInv',             '0x2000'),
                                        ('Gfx6KeepShaderCoher',            '0x0100'),
                                        ('Gfx6AvoidCpuMemoryCoher',        '0x0200'),
                                        ('Gfx9KeepShaderCoher',            '0x0400'),
                                        ('Gfx9AvoidCpuMemoryCoher',        '0x0800')";

DefineEnum = "'BarrierFilterOptions' : ('BarrierFilterDisabled',               '0x0000'),
                                        'SkipStrayExecutionDependencies',      '0x0001'),
                                        'SkipImageLayoutUndefined',            '0x0002'),
                                        'SkipDuplicateResourceBarriers',       '0x0004'),
                                        'ForceImageSharingModeExclusive',      '0x0008'),
                                        'SkipWithAppProfile',                  '0x0010'),
                                        'SkipWithAppProfileRegen',             '0x0020'),
                                        'SkipWithIntDevOverlay',               '0x0040')";

DefineEnum = "'DbgBarrierCmd' : ('DbgBarrierDrawNonIndexed',            '0x00000001'),
                                ('DbgBarrierDrawIndexed',               '0x00000002'),
                                ('DbgBarrierDrawIndirect',              '0x00000004'),
                                ('DbgBarrierDispatch',                  '0x00000008'),
                                ('DbgBarrierDispatchIndirect',          '0x00000010'),
                                ('DbgBarrierCopyBuffer',                '0x00000020'),
                                ('DbgBarrierCopyImage',                 '0x00000040'),
                                ('DbgBarrierCopyQueryPool',             '0x00000080'),
                                ('DbgBarrierClearColor',                '0x00000100'),
                                ('DbgBarrierClearDepth',                '0x00000200'),
                                ('DbgBarrierResolve',                   '0x00000400'),
                                ('DbgBarrierBeginRenderPass',           '0x00000800'),
                                ('DbgBarrierNextSubpass',               '0x00001000'),
                                ('DbgBarrierEndRenderPass',             '0x00002000'),
                                ('DbgBarrierSetResetEvent',             '0x00004000'),
                                ('DbgBarrierPipelineBarrierWaitEvents', '0x00008000'),
                                ('DbgBarrierQueryBeginEnd',             '0x00010000'),
                                ('DbgBarrierQueryReset',                '0x00020000'),
                                ('DbgBarrierExecuteCommands',           '0x00040000'),
                                ('DbgBarrierCmdBufStart',               '0x00080000'),
                                ('DbgBarrierCmdBufEnd',                 '0x00100000'),
                                ('DbgBarrierBindPipeline',              '0x00200000'),
                                ('DbgBarrierBindSetsPushConstants',     '0x00400000'),
                                ('DbgBarrierBindIndexVertexBuffer',     '0x00800000'),
                                ('DbgBarrierWriteTimestamp',            '0x01000000'),
                                ('DbgBarrierSetDynamicPipelineState',   '0x02000000'),
                                ('DbgBarrierVideo',                     '0x04000000'),
                                ('DbgBarrierOther',                     '0x80000000')";

DefineEnum = "'OptRenderStateCacheFlag' : ('OptRenderStateCacheMsaaState',                  '0x00000001'),
                                          ('OptRenderStateCacheColorBlendState',            '0x00000002'),
                                          ('OptRenderStateCacheDepthStencilState',          '0x00000004'),
                                          ('OptRenderStateCacheInputAssemblyState',         '0x00000008'),
                                          ('OptRenderStateCacheTriangleRasterState',        '0x00000010'),
                                          ('OptRenderStateCacheStaticPointLineRasterState', '0x00000020'),
                                          ('OptRenderStateCacheStaticDepthBias',            '0x00000040'),
                                          ('OptRenderStateCacheStaticBlendConst',           '0x00000080'),
                                          ('OptRenderStateCacheStaticDepthBounds',          '0x00000100'),
                                          ('OptRenderStateCacheStaticViewport',             '0x00000200'),
                                          ('OptRenderStateCacheStaticScissorRect',          '0x00000400'),
                                          ('OptRenderStateCacheStaticSamplePattern',        '0x00000800'),
                                          ('OptRenderStateCacheStaticGraphicsWaveLimits',   '0x00001000'),
                                          ('OptRenderStateCacheStaticComputeWaveLimits',    '0x00002000'),
                                          ('OptRenderStateCacheStaticAnisoLodCompensation', '0x00004000')";

DefineEnum = "'FeatureEnableMode': ('FeatureDefault',             '0'),
                                   ('FeatureForceEnable',         '1'),
                                   ('FeatureForceDisable',        '2')";

DefineEnum = "'PreciseAnisoMode' : ('EnablePreciseAniso',        '0'),
                                   ('DisablePreciseAnisoAfOnly', '1'),
                                   ('DisablePreciseAnisoAll',    '2')";

DefineEnum = "'OptimizeCmdbufMode' : ('EnableOptimizeForRenderPassContinue',    '0'),
                                     ('EnableOptimizeCmdbuf',                   '1'),
                                     ('DisableOptimizeCmdbuf',                  '2')";

DefineEnum = "'TextureFilterOptimizationSettings' : ('TextureFilterOptimizationsDisabled',    '0'),
                                                    ('TextureFilterOptimizationsEnabled',     '1'),
                                                    ('TextureFilterOptimizationsAggressive',  '2')";

Node = "Render Passes"
{
    Leaf
    {
        SettingName = "RenderPassNewEnable";
        SettingType = "BOOL_STR";
        Description = "Use new render passes";
        VariableName = "renderPassNewEnable";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassLogEnable";
        SettingType = "BOOL_STR";
        Description = "Write a graph visualization of each created render pass in .dot format";
        VariableName = "renderPassLogEnable";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassLogDirectory";
        SettingType = "STRING_DIR";
        Description = "Relative directory where render pass graphs are placed.\r\n
                       Root directory is determined in device.\r\n
                       Each unique render pass is in a separate file within that directory.\r\n
                       The log name is based on a hash of the render pass's create info.\r\n";
        VariableName = "renderPassLogDirectory";
        VariableType = "char";
        VariableDefaultWin = "VulkanRenderPasses\\";
        VariableDefaultLnx = "amdpal/";
        StringLength = "512";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassLogFlags";
        SettingType = "HEX_STR";
        Description = "A bitmask of flags that control what kind of information is written to the render pass log:\r\n"
                      "0x00000001: Include render graph.\r\n";
                      "0x00000002: Include command list.\r\n";
                      "0x00000004: Include original VkSubpassDependency edges.\r\n"
                      "0x00000008: Include waits and signal event info.\r\n"
                      "0x00000010: Include cache/layout synchronization info.\r\n"

        VariableName = "renderPassLogFlags";
        VariableType = "uint32_t";
        VariableDefault = "0xffffffff";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassForceWaitIdle";
        SettingType = "BOOL_STR";
        Description = "If true, forces a full pipeline idle between each node rather than relying on GPU events.\r\n";
        VariableName    = "renderPassForceWaitIdle";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassForceCacheInputCoher";
        SettingType = "HEX_STR";
        Description = "If non-zero, the following input/output caches are always force-flushed between each node\r\n";
        VariableName    = "renderPassForceCacheInputCoher";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassForceCacheOutputCoher";
        SettingType = "HEX_STR";
        Description = "If non-zero, the following input/output caches are always force-flushed between each node\r\n";
        VariableName    = "renderPassForceCacheOutputCoher";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "RenderPassAsyncEventEnable";
        SettingType = "BOOL_STR";
        Description = "Use asynchronous GPU events to wait between steps of a renderpass instance.";
        VariableName = "renderPassAsyncEventEnable";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }
}

Node = "Command Buffer Options"
{
    Leaf
    {
        SettingName = "CmdBufGpuEventMinAllocCount";
        SettingType = "UINT_STR";
        Description = "Minimum number of GPU events to allocate at once by the command buffer GPU event manager";
        VariableName = "cmdBufGpuEventMinAllocCount";
        VariableType = "uint32_t";
        VariableDefault = "128";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "UseSharedCmdAllocator";
        SettingType = "BOOL_STR";
        Description = "Use shared CmdAllocator for all command buffers";
        VariableName = "useSharedCmdAllocator";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorDataHeap";
        SettingType = "UINT_STR";
        Description = "The primary heap for the internal CmdAllocator for command data.\r\n
                       0: GpuHeapLocal\r\n
                       1: GpuHeapInvisible - This is invalid! Allocations must be mappable.\r\n
                       2: GpuHeapGartUswc\r\n
                       3: GpuHeapGartCacheable";
        VariableName = "cmdAllocatorDataHeap";
        VariableType = "Pal::GpuHeap";
        VariableDefault = "Pal::GpuHeapGartCacheable";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorDataAllocSize";
        SettingType = "UINT_STR";
        Description = "Size of allocation chunks used by CmdAllocators for command data";
        VariableName = "cmdAllocatorDataAllocSize";
        VariableType = "uint32_t";
        VariableDefault = "2097152";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorDataSubAllocSize";
        SettingType = "UINT_STR";
        Description = "Size of suballocations used by CmdAllocators for command data";
        VariableName = "cmdAllocatorDataSubAllocSize";
        VariableType = "uint32_t";
        VariableDefault = "65536";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorEmbeddedHeap";
        SettingType = "UINT_STR";
        Description = "The primary heap for the internal CmdAllocator for embedded data.\r\n
                       0: GpuHeapLocal\r\n
                       1: GpuHeapInvisible - This is invalid! Allocations must be mappable.\r\n
                       2: GpuHeapGartUswc\r\n
                       3: GpuHeapGartCacheable";
        VariableName = "cmdAllocatorEmbeddedHeap";
        VariableType = "Pal::GpuHeap";
        VariableDefault = "Pal::GpuHeapGartUswc";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorEmbeddedAllocSize";
        SettingType = "HEX_STR";
        VariableName = "cmdAllocatorEmbeddedAllocSize";
        Description = "Size of allocation chunks used by CmdAllocators for embedded data";
        VariableType = "uint32_t";
        VariableDefault = "0x20000";
    }

    Leaf
    {
        SettingName = "CmdAllocatorEmbeddedSubAllocSize";
        SettingType = "HEX_STR";
        VariableName = "cmdAllocatorEmbeddedSubAllocSize";
        Description = "Size of suballocations used by CmdAllocators for embedded data";
        VariableType = "uint32_t";
        VariableDefault = "0x4000";
    }

    Leaf
    {
        SettingName = "CmdAllocatorScratchHeap";
        SettingType = "UINT_STR";
        Description = "The primary heap for the internal CmdAllocator for GPU scratch memory.\r\n
                      Note: this field is ignored by PAL and will always be GpuHeapInvisible.\r\n
                       0: GpuHeapLocal\r\n
                       1: GpuHeapInvisible\r\n
                       2: GpuHeapGartUswc\r\n
                       3: GpuHeapGartCacheable";
        VariableName = "cmdAllocatorScratchHeap";
        VariableType = "Pal::GpuHeap";
        VariableDefault = "Pal::GpuHeapInvisible";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "CmdAllocatorScratchAllocSize";
        SettingType = "HEX_STR";
        VariableName = "cmdAllocatorScratchAllocSize";
        Description = "Size of allocation chunks used by CmdAllocators for GPU scratch memory";
        VariableType = "uint32_t";
        VariableDefault = "0x20000";
    }

    Leaf
    {
        SettingName = "CmdAllocatorScratchSubAllocSize";
        SettingType = "HEX_STR";
        VariableName = "cmdAllocatorScratchSubAllocSize";
        Description = "Size of suballocations used by CmdAllocators for GPU scratch memory";
        VariableType = "uint32_t";
        VariableDefault = "0x4000";
    }
}

Node = "Pipeline Options"
{
    Leaf
    {
        SettingName = "PipelineLinkTimeOptMode";
        SettingType = "UINT_STR";
        Description = "Controls how PAL's link-time pipeline optimizations are enabled:
                       \r\n0: Enabled unless VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT is set.
                       \r\n1: Optimizations always enabled.
                       \r\n2: Optimizations always disabled.";
        VariableName  = "pipelineLinkTimeOptMode";
        VariableType = "PipelineLinkTimeOptMode";
        VariableDefault = "PipelineLinkTimeOptApiControlled";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelinePreferNonLocalHeap";
        SettingType     = "BOOL_STR";
        Description     = "Store the Pipelines in system memory instead of LocalVis.
                           This could help if LocalVis is oversubscribed.\r\n";

        VariableName       = "pipelinePreferNonLocalHeap";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "PipelineFastCompileMode";
        SettingType = "UINT_STR";
        Description = "Controls how SC 'fast compile mode' (disable optimizations) is enabled:
                       \r\n0: 'Fast compile' disabled unless VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT is set.
                       \r\n1: 'Fast compile' always enabled (disables SC shader optimization).
                       \r\n2: 'Fast compile' always disabled (SC default optimizations enabled).";
        VariableName  = "pipelineFastCompileMode";
        VariableType = "PipelineFastCompileMode";
        VariableDefault = "PipelineFastCompileApiControlled";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "PipelineBinningMode";
        SettingType = "UINT_STR";
        Description = "Specifies whether to override binning setting for pipeline:
                       \r\n0: 'Default' follows the PBB global setting.
                       \r\n1: 'Disable' disables pipeline binning.
                       \r\n2: 'Enable' enables pipeline binning";
        VariableName  = "pipelineBinningMode";
        VariableType = "PipelineBinningMode";
        VariableDefault = "PipelineBinningModeDefault";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineUseProfileHashAsClientHash";
        SettingType     = "BOOL_STR";
        Description     = "If true, the profile hash (calculated exclusively from SPIRV + entry point) is used as PAL\r\n
                          client hash and will appear in e.g. GPUProfiler layer measurements.  Useful when writing and\r\n
                          updating pipeline profiles for applications.\r\n";

        VariableName       = "pipelineUseProfileHashAsClientHash";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineUseShaderHashAsProfileHash";
        SettingType     = "BOOL_STR";
        Description     = "If true, the shader hash (calcualte from SPIRV) is used as profile hash.\r\n";

        VariableName       = "pipelineUseShaderHashAsProfileHash";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineProfileRuntimeFile";
        SettingType     = "STRING";
        Description     = "Path to a JSON file that describes a shader app profile that is parsed at runtime.  This\r\n
                           setting only triggers on debug builds or builds made with the ICD_RUNTIME_APP_PROFILE=1\r\n
                           option.  This file has the same format as the JSON files used to build production shader\r\n
                           app profiles.";

        VariableName       = "pipelineProfileRuntimeFile";
        VariableType       = "char";
        VariableDefault    = "";
        StringLength       = "512";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineProfileDbgPrintProfileMatch";
        SettingType     = "BOOL_STR";
        Description     = "Prints a message to the debugger when a pipeline profile matches a pipeline.  Only valid\r\n
                           on debug builds or builds built with PAL_ENABLE_PRINTS_ASSERTS=1.";

        VariableName       = "pipelineProfileDbgPrintProfileMatch";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineProfileIgnoresAppProfile";
        SettingType     = "BOOL_STR";
        Description     = "If this is true, any production app profile-installed shader optimizations are ignored.";

        VariableName       = "pipelineProfileIgnoresAppProfile";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PipelineProfileHaltOnParseFailure";
        SettingType     = "BOOL_STR";
        Description     = "If the driver fails to parse a runtime profile JSON file, it will assert and enter into an
                           infinite loop if this setting is TRUE.\r\n";

        VariableName       = "pipelineProfileHaltOnParseFailure";
        VariableType       = "bool";
        VariableDefault    = "false";
        SettingScope       = "PrivateDriverKey";
    }

	Leaf
    {
        SettingName     = "DisableEmbedConstArrays";
        SettingType     = "BOOL_STR";
        Description     = "If indexable constant arrays end up as local variables instead of literals, this embeds them \r\n
						   into the shader code so they can be indexed instead of spilling to memory and reading back. \r\n";
        VariableName    = "disableEmbedConstArrays";
        VariableType    = "bool";
        VariableDefault = "false";
    }
}

Node = "Present"
{
    Leaf
    {
        SettingName = "UmdFramePacerControl";
        SettingType = "BOOL_STR";
        VariableName = "enableUmdFramePacer";
        Description = "Enable UMD frame pacer control.";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableFRTC";
        SettingType = "BOOL_STR";
        VariableName = "enableFrtc";
        Description = "Enable Frame Rate Target Control.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableTurboSync";
        SettingType = "BOOL_STR";
        VariableName = "enableTurboSync";
        Description = "Enable Turbo Sync control.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "FullscreenFrameMetadataSupport";
        SettingType = "BOOL_STR";
        VariableName = "fullScreenFrameMetadataSupport";
        Description = "Support Fullscreen Frame Metadata.";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "UseSdmaCompositingBlt";
        SettingType = "BOOL_STR";
        VariableName = "useSdmaCompositingBlt";
        Description = "For software compositing, perform an SDMA blt on the slave device instead of using its present queue.";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableMailboxPresentMode";
        SettingType = "BOOL_STR";
        VariableName = "enableMailboxPresentMode";
        Description = "Enable VK_PRESENT_MODE_MAILBOX_KHR present mode support on Windows OS.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

}

Node = "SPIRV Options"
{
    Leaf
    {
        SettingName = "EnablePipelineDump";
        SettingType = "BOOL_STR";
        VariableName = "enablePipelineDump";
        Description = "Enable pipeline dump, pipeline is stored with .pipe format.\r\n
                       You must set AMD_DEBUG_DIR and make sure $AMD_DEBUG_DIR + pipelineDumpDir is \r\n
                       an available directory.\r\n";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "PipelineDumpDir";
        SettingType = "STRING_DIR";
        VariableName = "pipelineDumpDir";
        Description = "Relative directory where pipeline info is dumped.\r\n
                       Root directory is determined by AMD_DEBUG_DIR environment variable.\r\n
                       Each unique pipeline is in a separate file within that directory.\r\n
                       The log name is based on a hash of the pipeline's create info and \r\n
                       which shader stages are active.\r\n";
        VariableType = "char";
        StringLength = "256";
        VariableDefaultWin = "SpvPipeline";
        VariableDefaultLnx = "spvPipeline";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableLog";
        SettingType = "UINT_STR";
        VariableName = "enableLog";
        Description = "Enable log general output and error message in LLPC and BIL.\r\n
                       0: Disable all logs\r\n
                       1: Enable output error message\r\n
                       2: Enable output general info\r\n
                       3: Enable output both general info and error message\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "LogFileName";
        SettingType = "STRING";
        VariableName = "logFileName";
        Description = "Filename of the log file in LLPC and BIL. Directory of the log file is PipelineDumpDir.\r\n
                       Note that logFileName does not includes <path> and <.txt>. Full path of log file is:\r\n
                       PipelineDumpDir+LogFileNameBil.txt or PipelineDumpDir+LogFileNameLlpc.txt.\r\n";
        VariableType = "char";
        StringLength = "256";
        VariableDefault = "spvLogInfo";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableDebug";
        SettingType = "BOOL_STR";
        VariableName = "enableDebug";
        Description = "Enable output diagnostic info. This info may added to AMD IL or external debug log files.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DebugLogFileName";
        SettingType = "STRING";
        VariableName = "debugLogFileName";
        Description = "Filename of the file to log debug information. \r\n
                       If the file name is empty, the message will be output to stderr.";
        VariableType = "char";
        StringLength = "256";
        VariableDefault = "debugLogInfo.txt";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ShaderReplaceMode";
        SettingType = "UINT_STR";
        VariableName = "shaderReplaceMode";
        Description = "Enable shader replacement.\r\n
                       This option is valid only if LLPC path is enabled. \r\n
                       0 - Disable shader replacement (default)\r\n
                       1 - Enable shader hash based shader replacement, for any shader whose hash is AAA,\r\n
                           if there is a file named shader_0xAAA_replace.spv under ShaderReplacementDir, this file will be\r\n
                           used to replace the original shader.\r\n
                       2 - Enable shader hash plus pipeline hash filter based shader replacement, shader hash based shader replacement
                           will only be enabled for pipelines whose hash is in ShaderReplacementPipelineHashs.\r\n
                       3 - Enable pipeline binary hash based pipeline binary replacement, for any pipeline binary whose hash is AAA,\r\n
                           if there is a file named PipelneXXX_0xAAA_replace.elf under ShaderReplacementDir, this file will be\r\n
                           used to replace the original pipeline binary.\r\n
                       4 - Enable replace ISA shader in the pipeline, For every pipeline in the ShaderReplacementPipelineHashs, would find\r\n
                           if there is a file named 0xAAA_replace.txt under ShaderReplacementDir, would be loaded for the replacement\r\n
                           the replace shader look like this \r\n
                           *----offset: ISACODE----*\r\n
                           848:0x7E120303  \r\n
                           1480:0x7E1E0303 \r\n
                           2592:0x7E0E030E \r\n ";

        VariableType = "ShaderReplaceMode";
        VariableDefault = "ShaderReplaceDisable";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ShaderReplaceDir";
        SettingType = "STRING_DIR";
        VariableName = "shaderReplaceDir";
        Description = "Relative directory where shader replacement files are stored.\r\n
                       Root directory is determined in device.\r\n";
        VariableType = "char";
        StringLength = "256";
        VariableDefaultWin = "ShaderReplace";
        VariableDefaultLnx = "ShaderReplace";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ShaderReplacePipelineHashes";
        SettingType = "STRING";
        VariableName = "shaderReplacePipelineHashes";
        Description = "Only valid if shaderReplaceMode is set to 2 and 4. This is a comma separated pipeline hash list.\r\n
                       Hash number is in big case, example hash list looks like: 0xAD033E031BF7CB6C,0x1B707F37B7DA34E3";
        VariableType = "char";
        StringLength = "512";
        VariableDefault = "";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableDropPipelineBinaryInst";
        SettingType = "BOOL_STR";
        VariableName = "enableDropPipelineBinaryInst";
        Description = "Drop specified instruction in pipeline binary for quick debugging shader.\r\n
                       It replaces all matching instruction opcodes with NOPs and needs to work\r\n
                       with DropPipelineBinaryInstToken and DropPipelineBinaryInstSize together.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DropPipelineBinaryInstToken";
        SettingType = "HEX_STR";
        VariableName = "dropPipelineBinaryInstToken";
        Description = "This option is valid when EnableDropPipelineBinaryInst is set to true.\r\n
                       It should be specified with the hex value of first dword of instruction.\r\n
                       For example: DropPipelineBinaryInstToken,0xE1084000";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DropPipelineBinaryInstMask";
        SettingType = "HEX_STR";
        VariableName = "dropPipelineBinaryInstMask";
        Description = "This option is valid when EnableDropPipelineBinaryInst is set to true.\r\n
                       It should be specified with the hex value to mask DropPipelineBinaryInstToken.\r\n
                       For example: DropPipelineBinaryInstMask,0xFFFF0000";
        VariableType = "uint32_t";
        VariableDefault = "0xFFFFFFFF";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DropPipelineBinaryInstSize";
        SettingType = "UINT_STR";
        Description = "This option is valid when EnableDropPipelineBinaryInst is set to true.\r\n
                       It should be specified with the size in dword of instruction to be dropped.";
        VariableName = "dropPipelineBinaryInstSize";
        VariableType = "uint32_t";
        VariableDefault = "1";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableSpvPerfOptimal";
        SettingType = "BOOL_STR";
        VariableName = "enableSpvPerfOptimal";
        Description = "[BIL ONLY] Generate optimized IL codes for performance purpose.\r\n
                       This may break some precision rules and may not produce 100% conforming IL codes.\r\n
                       Therefore, the option should only be enabled via application profile.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableSpvValidation";
        SettingType = "BOOL_STR";
        VariableName = "enableSpvValidation";
        Description = "[BIL ONLY] Enable SPIR-V binary validation.";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ZeroInitILRegs";
        SettingType = "BOOL_STR";
        VariableName = "zeroInitIlRegs";
        Description = "[BIL ONLY] Zero initialize AMD IL registers.\r\n";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "SkipUnsupportedOpCode";
        SettingType = "BOOL_STR";
        VariableName = "skipUnsupportedOpCode";
        Description = "[BIL ONLY] Skip unsupported SPIR-V instructions.\r\n";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "LlpcOptions";
        SettingType = "STRING";
        VariableName = "llpcOptions";
        Description = "[LLPC ONLY] LLPC general options. Max length of the option is 256.
                       \r\nfor example:
                       \r\nDisable Loop unroll: -pragma-unroll-threshold=1
                       \r\nEnable si-scheduler: -enable-si-scheduler
                       \r\nPlease see amdllpc -help or -help-hidden for detail";
        VariableType = "char";
        StringLength = "256";
        VariableDefault = "";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ShaderCacheMode";
        SettingType = "UINT_STR";
        Description = "Controls whether the Device shader cache should be used to try to avoid redundant\r\n
                       shader compiles
                       \r\n0: Shader Cache is disabled.
                       \r\n1: Shader Cache is enabled for runtime use only.
                       \r\n2: Shader Cache is enabled with on-disk file backing.
                       \r\n3: Shader Cache is forced on with on-disk file backing even for applications that specify pipeline caches.";
        VariableName  = "shaderCacheMode";
        VariableType = "ShaderCacheMode";
        VariableDefault = "ShaderCacheEnableRuntimeOnly";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "AllowVkPipelineCachingToDisk";
        SettingType = "BOOL_STR";
        Description = "Controls whether the pipeline compiler enables Pal's archive-file based\r\n
                       caching for saving shader ELFs. (Default: FALSE)\r\n
                       Related environment variables
                       \r\nAMD_ARCHIVE_DISK_CACHE_PATH: Path to where archive file is to be stored (optional)
                       \r\nAMD_ARCHIVE_APP_PREFIX     : Fixed prefix string for generated archive file name (optional)";
        VariableName  = "usePalPipelineCaching";
        VariableType = "bool";
        VariableDefault = "true";
    }

    Leaf
    {
        SettingName = "PipelineCachingEnvironmentVariable";
        SettingType = "STRING";
        Description = "Environment variable to check for to enable Pal Pipeline Caching. This allows launcher\r\n
                       applications to dynamically control whether we cache pipleline ELFs or not.\r\n
                       When converted to an integer any 0 value will be treated as False, and any non-zero value\r\n
                       will be treated as true.\r\n
                       \r\n
                       Functionally equivelant to setting UsePalPipelineCaching = True/False";
        VariableName  = "pipelineCachingEnvironmentVariable";
        VariableType = "char";
        StringLength = "256";
        VariableDefault = "AMD_VK_USE_PIPELINE_CACHE";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "UsePipelineCachingDefaultLocation";
        SettingType = "BOOL_STR";
        Description = "Allow use of default pipeline cache location.";
        VariableName  = "usePipelineCachingDefaultLocation";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "PipelineCachingDefaultLocation";
        SettingType = "STRING_DIR";
        Description = "Default sub folder to write PAL pipeline cache if not specified by environment variable\r\n
                       AMD_VK_PIPELINE_CACHE_PATH.\r\n";
        VariableName  = "pipelineCachingDefaultLocation";
        VariableType = "char";
        StringLength = "256";
        VariableDefaultWin = "\\AMD\\VkCache\\";
        VariableDefaultLnx = "/AMD/VkCache/";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "MarkPipelineCacheWithBuildTimestamp";
        SettingType = "BOOL_STR";
        Description = "Controles whether the pipline cache is tagged with the build timestamp.\r\n
                       This provides extra stability by forcing a cache rebuild for every new driver released. \r\n
                       May be useful to disable during rapid iteration. (Default: TRUE)";
        VariableName  = "markPipelineCacheWithBuildTimestamp";
        VariableType = "bool";
        VariableDefault = "true";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "FilterPipelineDumpByType";
        SettingType = "HEX_STR";
        Description = "Filter which types of pipeline dump are disabled:\r\n
                        0x00 - Do not disable any pipeline type \r\n
                        0x01 - Disable pipeline dump for Cs pipelines \r\n
                        0x02 - Disable pipeline dump for NGG pipelines \r\n
                        0x04 - Disable pipeline dump for Gs pipelines \r\n
                        0x08 - Disable pipeline dump for Tess pipelines \r\n
                        0x10 - Disable pipeline dump for VsPs pipelines \r\n
                        \r\n
                        These options can be used to dump pipelines of a specific type. By default,\r\n
                        all the pipelines are logged.";
        VariableName = "filterPipelineDumpByType";
        VariableType = "uint32_t";
        VariableDefault = "PipelineDumpFilterNone";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "FilterPipelineDumpByHash";
        SettingType = "HEX64_STR";
        Description = "If non-zero, only dump the pipeline with this compiler hash.";
        VariableName = "filterPipelineDumpByHash";
        VariableType = "uint64_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DumpDuplicatePipelines";
        SettingType = "BOOL_STR";
        Description = "If true, duplicate pipelines will be dumped to a file with a numeric suffix attached\r\n
                       to the filename to distinguish each copy of the pipeline.";
        VariableName = "dumpDuplicatePipelines";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope = "PrivateDriverKey";
    }

}

Node = "Debugging"
{
    Leaf
    {
        SettingName = "DbgBarrierPostCmdEnable";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostCmdEnable";
        Description = "Triggers a CmdBarrier call after any command in the given mask.  The barrier behavior is\r\n
                       controlled by the other DbgBarrierPost* settings in this category.\r\n
                       \r\n
                       Requires VK_ENABLE_DEBUG_BARRIERS=1 to take effect\r\n
                       \r\n
                       0x00000001: Any non-indexed draw (including indirect)\r\n
                       0x00000002: Any indexed draw (including indirect)\r\n
                       0x00000004: Any indirect draw\r\n
                       0x00000008: Any direct dispatch\r\n
                       0x00000010: Any indirect dispatch\r\n
                       0x00000020: Any transfer copy involving a buffer\r\n
                       0x00000040: Any transfer copy involving an image\r\n
                       0x00000080: Any transfer copy involving a query pool\r\n
                       0x00000100: Any color clear operation (including render pass clears)\r\n
                       0x00000200: Any depth-stencil clear operation (including render pass clears)\r\n
                       0x00000400: Any resolve operation (including render pass resolves)\r\n
                       0x00000800: vkCmdBeginRenderPass\r\n
                       0x00001000: vkCmdNextSubpass\r\n
                       0x00002000: vkCmdEndRenderPass\r\n
                       0x00004000: vkCmdSetEvent or vkCmdResetEvent\r\n
                       0x00008000: vkCmdPipelineBarrier or vkCmdWaitEvents\r\n
                       0x00010000: vkCmdBeginQuery or vkCmdEndQuery\r\n
                       0x00020000: vkCmdResetQueryPool\r\n
                       0x00040000: vkCmdExecuteCommands\r\n
                       0x00080000: Start of the command buffer\r\n
                       0x00100000: End of the command buffer\r\n
                       0x00200000: vkCmdBindPipeline\r\n
                       0x00400000: vkCmdBindDescriptorSets or vkCmdPushConstants\r\n
                       0x00800000: vkCmdBindIndexBuffer or vkCmdBindVertexBuffers\r\n
                       0x01000000: vkCmdWriteTimestamp\r\n
                       0x02000000: Any vkCmdSet* which programs dynamic pipeline state\r\n
                       0x04000000: Any video operations\r\n
                       0x80000000: Any other command not listed above\r\n
                       0x8FFFFFFF: All commands (heavyweight option)\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPostWaitPipePoint";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostWaitPipePoint";
        Description = "For post-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the\r\n
                       barrier will wait.\r\n
                       \r\n
                       0: HwPipeTop (heavyweight option)\r\n
                       1: HwPipePostIndexFetch, HwPipePreCs, or HwPipePreBlt\r\n
                       3: HwPipePreRasterization\r\n
                       4: HwPipePostPs\r\n
                       5: HwPipePostCs\r\n
                       6: HwPipePostBlt\r\n
                       7: HwPipeBottom\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPostSignalPipePoint";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostSignalPipePoint";
        Description = "For post-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the\r\n
                       barrier is signaled.\r\n
                       \r\n
                       0: HwPipeTop\r\n
                       1: HwPipePostIndexFetch, HwPipePreCs, or HwPipePreBlt\r\n
                       3: HwPipePreRasterization\r\n
                       4: HwPipePostPs\r\n
                       5: HwPipePostCs\r\n
                       6: HwPipePostBlt\r\n
                       7: HwPipeBottom (heavyweight option)\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPostCacheSrcMask";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostCacheSrcMask";
        Description = "For post-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags source\r\n
                       mask.\r\n
                       \r\n
                       0x00000001: CoherCpu\r\n
                       0x00000002: CoherShader\r\n
                       0x00000004: CoherCopy\r\n
                       0x00000008: CoherColorTarget\r\n
                       0x00000010: CoherDepthStencilTarget\r\n
                       0x00000020: CoherResolve\r\n
                       0x00000040: CoherClear\r\n
                       0x00000080: CoherIndirectArgs\r\n
                       0x00000100: CoherIndexData\r\n
                       0x00000200: CoherQueueAtomic\r\n
                       0x00000400: CoherTimestamp\r\n
                       0x00000800: CoherCeLoad\r\n
                       0x00001000: CoherCeDump\r\n
                       0x00002000: CoherStreamOut\r\n
                       0x00004000: CoherMemory\r\n
                       0x00007FFF: CoherAllUsages (heavyweight option)\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPostCacheDstMask";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPostCacheDstMask";
        Description = "For post-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags destination\r\n
                       mask.\r\n
                       \r\n
                       0x00000001: CoherCpu\r\n
                       0x00000002: CoherShader\r\n
                       0x00000004: CoherCopy\r\n
                       0x00000008: CoherColorTarget\r\n
                       0x00000010: CoherDepthStencilTarget\r\n
                       0x00000020: CoherResolve\r\n
                       0x00000040: CoherClear\r\n
                       0x00000080: CoherIndirectArgs\r\n
                       0x00000100: CoherIndexData\r\n
                       0x00000200: CoherQueueAtomic\r\n
                       0x00000400: CoherTimestamp\r\n
                       0x00000800: CoherCeLoad\r\n
                       0x00001000: CoherCeDump\r\n
                       0x00002000: CoherStreamOut\r\n
                       0x00004000: CoherMemory\r\n
                       0x00007FFF: CoherAllUsages (heavyweight option)\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreCmdEnable";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreCmdEnable";
        Description = "Triggers a CmdBarrier call before any command in the given mask.  The barrier behavior is\r\n
                       controlled by the other DbgBarrierPre* settings in this category.\r\n
                       \r\n
                       Requires VK_ENABLE_DEBUG_BARRIERS=1 to take effect\r\n
                       \r\n
                       For further documentation, consult the corresponding DbgBarrierPostCmdEnable command.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreWaitPipePoint";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreWaitPipePoint";
        Description = "For pre-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the\r\n
                       barrier will wait.\r\n
                       \r\n
                       For further documentation, consult DbgBarrierPostWaitPipePoint.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreSignalPipePoint";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreSignalPipePoint";
        Description = "For pre-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the\r\n
                       barrier is signaled.\r\n
                       \r\n
                       For further documentation, consult DbgBarrierPostSignalPipePoint.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreCacheSrcMask";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreCacheSrcMask";
        Description = "For pre-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags source\r\n
                       mask.\r\n
                       \r\n
                       For further documentation, consult DbgBarrierPostCacheSrcMask.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "DbgBarrierPreCacheDstMask";
        SettingType = "HEX_STR";
        VariableName = "dbgBarrierPreCacheDstMask";
        Description = "For pre-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags destination\r\n
                       mask.\r\n
                       \r\n
                       For further documentation, consult DbgBarrierPostCacheDstMask.\r\n";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PrivateDriverKey";
    }
}

Node = "General"
{
    Leaf
    {
        SettingName     = "VulkanOverlayEnable";
        SettingType     = "HEX_STR";
        Description     = "Enable specific channels of the Vulkan debug overlay through a bitmask.  Only takes effect\r\n
                           for drivers compiled with the .intdev target (VK_INTERNAL_DEVELOPER=1).  The recognized\r\n
                           channels are:\r\n
                           \r\n
                           0x00000001: OverlayPresentInfo      - Information about presents\r\n
                           0x00000002: OverlayBarrierInfo      - Information about barriers\r\n
                           0x00000004: OverlayBarrierFiltering - Barrier filter layer debugging information\r\n";
        VariableName    = "overlayEnable";
        VariableType    = "uint32_t";
        VariableDefault = "0";
    }

    Leaf
    {
        SettingName     = "VertexBufferTableInstanceRingSize";
        SettingType     = "UINT_STR";
        Description     = "Instanced vertex buffer table ring size.";
        VariableName    = "vbTableInstanceRingSize";
        VariableType    = "uint32_t";
        VariableDefault = "1024";
    }

    Leaf
    {
        SettingName     = "ResourceBarrierOptions";
        SettingType     = "HEX_STR";
        Description     = "Force command buffer based barrier queue usage.\r\n
                           0x0000 - DefaultResourceBarrier - Default barrier queues\r\n
                           0x4000 - CombinedAccessMask - Ignore Vulkan separate access mask rule\r\n
                           0x8000 - SkipDstCacheInv - Do not invalidate dest caches if src cache was not updated\r\n
                           0x2000 - PreferFlushOverInv - By default we invalidate input caches to accomodate the\r\n
                                    Vulkan separate access mask rule. When this is set we'll instead flush all\r\n
                                    output caches instead to achieve the same goal.\r\n
                                    Mutually exclusive with SkipDstCacheInv.\r\n
                                    May or may not be beneficial for certain applications.\r\n
                           0x0100 - Gfx6KeepShaderCoher - Keep shader domain always coherent on GFX6-GFX8 thus\r\n
                                    avoiding L2 cache flushes/invalidations in shader-to-shader barrier cases at\r\n
                                    the expense of always flushing/invalidating L1 caches.\r\n
                                    This does NOT violate the Vulkan separate access mask rule.\r\n
                                    This behavior is likely preferred on GFX6-GFX8.\r\n
                           0x0200 - Gfx6AvoidCpuMemoryCoher - Avoid CPU and memory domain coherency on GFX6-GFX8\r\n
                                    unless corresponding flags are explicitly requested to lower the number of L2\r\n
                                    cache flushes/invalidations.\r\n
                                    This does NOT violate the Vulkan separate access mask rule.\r\n
                                    This behavior may or may not be beneficial on GFX6-GFX8.\r\n
                           0x0400 - Gfx9KeepShaderCoher - Keep shader domain always coherent on GFX9+ thus\r\n
                                    avoiding L2 cache flushes/invalidations in shader-to-shader barrier cases at\r\n
                                    the expense of always flushing/invalidating L1 caches.\r\n
                                    This does NOT violate the Vulkan separate access mask rule.\r\n
                                    This behavior may not be beneficial on GFX9+.\r\n
                           0x0800 - Gfx9AvoidCpuMemoryCoher - Avoid CPU and memory domain coherency on GFX9+\r\n
                                    unless corresponding flags are explicitly requested to lower the number of L2\r\n
                                    cache flushes/invalidations.\r\n
                                    This does NOT violate the Vulkan separate access mask rule.\r\n
                                    This behavior is preferred on GFX9+ as all other accesses go through the L2.\r\n
                           Default of 0x8A00\r\n
                           \r\n
                           Scrambled Registry Key:\r\n
                           Default Value: SkipDstCacheInv | Gfx6AvoidCpuMemoryCoher | Gfx9AvoidCpuMemoryCoher";
        VariableName    = "resourceBarrierOptions";
        VariableType    = "uint32_t";
        VariableDefault = "0x8A00";
    }

    Leaf
    {
        SettingName     = "BarrierFilterOptions";
        SettingType     = "HEX_STR";
        Description     = "Flags to describe strategies of avoiding barrier operations. These are illegal\r\n
                           optimizations according to the Vulkan spec, but may be acceptable for some applications.\r\n
                           0x0000 - BarrierFilterDisabled - Do nothing (default)\r\n
                           0x0001 - SkipStrayExecutionDependencies - The driver is unable to know if a source\r\n
                                    pipeline stage mask is for a standalone execution dependency or the access scope\r\n
                                    of a skippable memory dependency. Checking for the source and destination\r\n
                                    pipeline stage masks doesn't always provide the developer's intent either.\r\n
                           0x0002 - SkipImageLayoutUndefined - Ignore image memory barrier transitions out of\r\n
                                    undefined in the hope that there will be a full coverage clear to the image next\r\n
                                    making this likely mask RAM initialization redundant. Transitions to transfer\r\n
                                    dst optimal are not skipped to avoid issues with slow clears and copies, which\r\n
                                    require initialized metadata.\r\n
                           0x0004 - SkipDuplicateResourceBarriers - Ignores resource barriers that have the same\r\n
                                    source and destination parameters in case a full cross-bar sync isn't required.\r\n
                           0x0008 - ForceImageSharingModeExclusive - Exclusive queue family access reduces some\r\n
                                    memory dependency operations and removes the restriction that the image layout\r\n
                                    must be supported for multiple queue families. VK_SHARING_MODE_CONCURRENT is only\r\n
                                    acceptable to ignore when the application unnecessarily specified extra queue\r\n
                                    families without accessing the resource using them. Setting this option illegally\r\n
                                    might avoid all the pitfalls in a given application, but they are too numerous to\r\n
                                    list (e.g. requiring a decompress on an async compute queue).\r\n
                           0x0010 - SkipWithAppProfile - Filter all requested pipeline barriers in an application\r\n
                                    profile specified by the setting BarrierFilterProfileFile.\r\n
                           0x0020 - SkipWithAppProfileRegen - Same as SkipWithAppProfile but the pipeline hashes\r\n
                                    are not considered in order to regenerate strong barrier hashes after any\r\n
                                    application updates to its shaders.\r\n
                           0x0040 - SkipWithIntDevOverlay - Manually remove barriers using keyboard shortcuts to\r\n
                                    visualize their effects. Use in conjunction with the developer overlay. See\r\n
                                    the setting VulkanOverlayEnable OverlayBarrierFiltering option for details.\r\n
                                    SkipWithAppProfile and SkipWithAppProfileRegen may be used simultaneously to\r\n
                                    refine or regenerate an existing profile.";
        VariableName    = "barrierFilterOptions";
        VariableType    = "uint32_t";
        VariableDefault = "0x0000";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "BarrierFilterProfileFile";
        SettingType     = "STRING";
        Description     = "Path to a file that contains application-specific barrier filter profiles. The contents\r\n
                           are read on startup and used if BarrierFilterOptions SkipWithAppProfile,\r\n
                           SkipWithAppProfileRegen, or SkipWithIntDevOverlay are set. On exit, an updated profile is\r\n
                           written to this same file. This setting only triggers on debug builds or builds made with\r\n
                           the VK_INTERNAL_DEVELOPER=1 option.";
        VariableName    = "barrierFilterProfileFile";
        VariableType    = "char";
        VariableDefault = "";
        StringLength    = "512";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "ExcessivePipelineCacheCountThreshold";
        SettingType     = "UINT_STR";
        Description     = "The number of pipeline cache count we treat as excessive and thus a smaller internal implementation is used for pipeline cache.\r\n";
        VariableName    = "excessivePipelineCacheCountThreshold";
        VariableType    = "uint32_t";
        VariableDefault = "256";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "EnumPreferredDeviceIndex";
        SettingType     = "UINT_STR";
        Description     = "If not UINT_MAX, this PAL enumerated device index will always be returned as the first enumerated physical device.";
        VariableName    = "enumPreferredDeviceIndex";
        VariableType    = "uint32_t";
        VariableDefault = "0xffffffff";
    }

    Leaf
    {
        SettingName     = "RobustBufferAccess";
        SettingType     = "UINT_STR";
        Description     = "Force VkPhysicalDeviceFeatures::robustBufferAccess.\r\n
                           0 - Default, use appliation setting\r\n
                           1 - Force Enable\r\n
                           2 - Force Disable\r\n
                           Default Value: 0";
        VariableName    = "robustBufferAccess";
        VariableType    = "FeatureEnableMode";
        VariableDefault = "FeatureDefault";
    }

    Leaf
    {
        SettingName     = "LenientInstanceFuncQuery";
        SettingType     = "BOOL_STR";
        Description     = "Allows instance-level functions to be queried using vkGetDeviceProcAddr.\r\n";
        VariableName    = "lenientInstanceFuncQuery";
        VariableType    = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName     = "AppProfileDumpDir";
        SettingType     = "STRING";
        Description     = "Determines where the vkAppProfile.txt file will be written to. This file contains \r\n
                           the app profile enumeration index.\r\n";
        VariableName       = "appProfileDumpDir";
        VariableType       = "char";
        VariableDefault    = "";
        StringLength       = "512";
    }

    Leaf
    {
        SettingName     = "OptEnablePrt";
        SettingType     = "BOOL_STR";
        Description     = "Enable PRT feature in general. The detailed feature set is decided according to caps \r\n
                           reported by Pal. \r\n";
        VariableName    = "optEnablePrt";
        VariableType    = "bool";
        VariableDefault = "true";
    }
}

Node = "Memory"
{
    Leaf
    {
        SettingName     = "MemoryCustomDeviceAllocationCountLimit";
        SettingType     = "UINT_STR";
        Description     = "Custom device allocation count limitation, when larger than 0.\r\n";
        VariableName    = "memoryCustomDeviceAllocationCountLimit";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryBaseAddrAlignment";
        SettingType     = "HEX_STR";
        Description     = "All VkMemory memory objects will have the following the GPU VA base address alignment.\r\n";
        VariableName    = "memoryBaseAddrAlignment";
        VariableType    = "uint32_t";
        VariableDefault = "0x80000";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryBaseAddrAlignmentCpuVisibleWin32";
        SettingType     = "HEX_STR";
        Description     = "On 32-bit Windows builds, the following GPU VA base alignment is used for host-visible\r\n
                           memory types instead of MemoryBaseVaAlign.\r\n";
        VariableName    = "memoryBaseAddrAlignmentCpuVisibleWin32";
        VariableType    = "uint32_t";
        VariableDefault = "0x20000";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryEnableRemoteBackupHeap";
        SettingType     = "BOOL_STR";
        Description     = "If true, the remote (GART USWC) heap is enabled as a secondary heap for all VkMemory\r\n
                           objects created using a GPU-local preferred heap. (true by default)\r\n";
        VariableName    = "memoryEnableRemoteBackupHeap";
        VariableType    = "bool";
        VariableDefault = "true";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryDeviceOverallocationAllowed";
        SettingType     = "BOOL_STR";
        Description     = "Device-local memory that is explicitly allocated by the application can tracked on a per-device\r\n
                           and per-heap basis. Once the size of a target heap is reached, VK_OUT_OF_DEVICE_MEMORY will\r\n
                           be returned. Setting this parameter to TRUE will disable such tracking by DEFAULT. This parameter\r\n
                           can be overridden by the VK_AMD_memory_overallocation_behavior device extension and specific\r\n
                           app profiles (unless MemoryDeviceOverallocationNonOverridable is set to TRUE).";
        VariableName    = "memoryDeviceOverallocationAllowed";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryDeviceOverallocationNonOverridable";
        SettingType     = "BOOL_STR";
        Description     = "MemoryDeviceOverallocationAllowed can be overriden by the VK_AMD_memory_overallocation_behavior\r\n
                           device extension and specific app profiles unless this parameter is set to TRUE.";
        VariableName    = "memoryDeviceOverallocationNonOverridable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityDefault";
        SettingType     = "HEX_STR";
        Description     = "Default priority of all VkMemory objects as two hex digits.  The first (most-significant)\r\n
                           digit defines the priority level, and the second digit defines the priority offset.\r\n
                           \r\n
                           Valid priority level values (Pal::GpuMemPriority) are:\r\n
                           \r\n
                           0: Unused\r\n
                           1: VeryLow\r\n
                           2: Low\r\n
                           3: Normal\r\n
                           4: High\r\n
                           5: VeryHigh\r\n
                           \r\n
                           Valid priority offset values (Pal::GpuMemPriorityOffset) are:\r\n
                           0: Offset0 (same as base level)\r\n
                           1: Offset1\r\n
                           2: Offset2\r\n
                           3: Offset3\r\n
                           4: Offset4\r\n
                           5: Offset5\r\n
                           6: Offset6\r\n
                           7: Offset7\r\n";

        VariableName    = "memoryPriorityDefault";
        VariableType    = "uint32_t";
        VariableDefault = "0x30";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageAny";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one image.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageAny";
        VariableType    = "uint32_t";
        VariableDefault = "0x30";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageShaderRead";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one image shader-readable image.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageShaderRead";
        VariableType    = "uint32_t";
        VariableDefault = "0x30";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageShaderWrite";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one shader-writable (storage) image.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageShaderWrite";
        VariableType    = "uint32_t";
        VariableDefault = "0x30";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageColorTarget";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one image that can be a color target.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageColorTarget";
        VariableType    = "uint32_t";
        VariableDefault = "0x40";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "MemoryPriorityImageDepthStencil";
        SettingType     = "HEX_STR";
        Description     = "Priority of all VkMemory objects containing at least one image that can be a depth-stencil.\r\n
                           \r\n
                           See MemoryPriorityDefault for valid values.\r\n";

        VariableName    = "memoryPriorityImageDepthStencil";
        VariableType    = "uint32_t";
        VariableDefault = "0x40";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "HeapBudgetRatioOfHeapSizeLocal";
        SettingType     = "UINT_STR";
        Description     = "On wddm1 and linux, there's no os functionality to report memory budget. We fudge heap\r\n
                           budget size as HeapBudgetRatioOfHeapSizeLocal% of heap size for GpuHeapLocal.\r\n
                           Valid value is [0, 100].\r\n";

        VariableName    = "heapBudgetRatioOfHeapSizeLocal";
        VariableType    = "uint32_t";
        VariableDefault = "95";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "HeapBudgetRatioOfHeapSizeInvisible";
        SettingType     = "UINT_STR";
        Description     = "On wddm1 and linux, there's no os functionality to report memory budget. We fudge heap\r\n
                           budget size as HeapBudgetRatioOfHeapSizeInvisible% of heap size for GpuHeapInvisible\r\n
                           Valid value is [0, 100].\r\n";

        VariableName    = "heapBudgetRatioOfHeapSizeInvisible";
        VariableType    = "uint32_t";
        VariableDefault = "95";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "HeapBudgetRatioOfHeapSizeNonlocal";
        SettingType     = "UINT_STR";
        Description     = "On wddm1 and linux, there's no os functionality to report memory budget. We fudge heap\r\n
                           budget size as HeapBudgetRatioOfHeapSizeNonlocal% of heap size for GpuHeapGartUswc and GpuHeapGartCacheable.\r\n
                           Valid value is [0, 100].\r\n";

        VariableName    = "heapBudgetRatioOfHeapSizeNonlocal";
        VariableType    = "uint32_t";
        VariableDefault = "95";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "TransferGranularityUniversalOverride";
        SettingType     = "HEX_STR";
        Description     = "Override reported minImageTransferGranularity field for graphics queue families.  This\r\n
                           is encoded as a hex string of the form 0xb000zzyyxx, where 'xx', 'yy', and 'zz' are the\r\n
                           reported transfer granularities in the X, Y and Z extents respectively, and 'b' is\r\n
                           a control flag: if 'b' is non-zero, this override is applies; otherwise the standard\r\n
                           transfer granularity is used.\r\n";
        VariableName    = "transferGranularityUniversalOverride";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "TransferGranularityComputeOverride";
        SettingType     = "HEX_STR";
        Description     = "Override reported minImageTransferGranularity field for compute queue families.  For how\r\n
                          this value is interpreted by the driver, see the description for\r\n
                          TransferGranularityUniversalOverride.\r\n";
        VariableName    = "transferGranularityComputeOverride";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "TransferGranularityDmaOverride";
        SettingType     = "HEX_STR";
        Description     = "Override reported minImageTransferGranularity field for DMA (i.e. SDMA) queue families.\r\n
                          For how this value is interpreted by the driver, see the description for\r\n
                          TransferGranularityUniversalOverride.\r\n";
        VariableName    = "transferGranularityDmaOverride";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }
}

Node = "Optimization"
{
    Leaf
    {
        SettingName     = "ForceAppProfileEnable";
        SettingType     = "BOOL_STR";
        Description     = "Forces a particular AppProfile value.  The profile selected is the value of ForceAppProfileValue.\r\n";
        VariableName    = "forceAppProfileEnable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "ForceAppProfileValue";
        SettingType     = "UINT_STR";
        Description     = "Forces a particular AppProfile value.  This value is the integer value of the AppProfile enum.  Ignored unless ForceAppProfileEnable is true.\r\n";
        VariableName    = "forceAppProfileValue";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PreciseAnisoMode";
        SettingType     = "UINT_STR";
        Description     = "PreciseAnisoMode denotes whether preciseAniso will be enabled:\r\n
                          0(EnablePreciseAniso):        precisAniso will be enabled. Highest image quality.\r\n
                          1(DisablePreciseAnisoAfOnly): precisAniso will be disabled only for anisotropic samplers.\r\n
                          2(DisablePreciseAnisoAll):    precisAniso will be disabled for all samplers. Lowest image quality.\r\n";
        VariableName    = "preciseAnisoMode";
        VariableType    = "PreciseAnisoMode";
        VariableDefault = "DisablePreciseAnisoAfOnly";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "UseAnisoThreshold";
        SettingType     = "BOOL_STR";
        Description     = "Supply the threshold value for anisotropic filtering (DisablePreciseAniso needs to be true also)\r\n";
        VariableName    = "useAnisoThreshold";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "AnisoThreshold";
        SettingType     = "FLOAT_STR";
        Description     = "The threshold value for anisotropic filtering (DisablePreciseAniso & UseAnisoThreshold need to be true also)\r\nDefault value (0.25) preserves the Pal behaviour";
        VariableName    = "anisoThreshold";
        VariableType    = "float";
        VariableDefault = "0.25";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "UseFlipHint";
        SettingType     = "BOOL_STR";
        Description     = "Use flip hint for swapchain. Linux Only. The X Server make the final decision whether to go async flip.";
        VariableName    = "useFlipHint";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "BackgroundFullscreenPresent";
        SettingType     = "HEX_STR";
        Description     = "Force fullscreen exclusive presents when detected safe.  The following combination of\r\n
                           flags control whether this feature is enabled for a particular OS + swapchain combination:\r\n
                           \r\n
                           0x0000001 - Win7-8 + VK_PRESENT_MODE_IMMEDIATE_KHR\r\n
                           0x0000002 - Win7-8 + VK_PRESENT_MODE_MAILBOX_KHR\r\n
                           0x0000004 - Win7-8 + VK_PRESENT_MODE_FIFO_KHR\r\n
                           0x0000008 - Win7-8 + VK_PRESENT_MODE_FIFO_RELAXED_KHR\r\n
                           0x0000010 - Win10  + VK_PRESENT_MODE_IMMEDIATE_KHR\r\n
                           0x0000020 - Win10  + VK_PRESENT_MODE_MAILBOX_KHR\r\n
                           0x0000040 - Win10  + VK_PRESENT_MODE_FIFO_KHR\r\n
                           0x0000080 - Win10  + VK_PRESENT_MODE_FIFO_RELAXED_KHR\r\n
                           0x0000100 - Win7-8 + Multi-GPU\r\n
                           0x0000200 - Win10  + Multi GPU\r\n";
        VariableName    = "backgroundFullscreenPresent";
        VariableType    = "uint32_t";
        VariableDefault = "0x3ff";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "BackgroundFullscreenFailureDisableCount";
        SettingType     = "UINT_STR";
        Description     = "Fullscreen presents may fail due to unexpected errors, although these cases are rare.\r\n
                           Failing a fullscreen present and reattempting to acquire exclusive access causes dropped\r\n
                           frames and screen flickering.  This is a fail-safe setting that permanently disables the\r\n
                           the fullscreen present logic after the given number of consecutive unexpected failures.\r\n";
        VariableName    = "backgroundFullscreenFailureDisableCount";
        VariableType    = "uint32_t";
        VariableDefault = "2";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "BackgroundFullscreenSuccessResetCount";
        SettingType     = "UINT_STR";
        Description     = "Reset the failure count only after this many consecutive successful fullscreen presents.\r\n
                           A large value for this setting is used to guarantee that we are consistently presenting\r\n
                           in fullscreen instead of rapidly ping-ponging between fullscreen and windowed presents.\r\n";
        VariableName    = "backgroundFullscreenSuccessResetCount";
        VariableType    = "uint32_t";
        VariableDefault = "64";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "BackgroundFullscreenIgnorePresentErrors";
        SettingType     = "BOOL_STR";
        Description     = "When forcing fullscreen presents, this flag will ignore unexpected errors on any failed\r\n
                           present.\r\n";
        VariableName    = "backgroundFullscreenIgnorePresentErrors";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ImageTilingOptMode";
        SettingType = "UINT_STR";
        Description = "Hints to PAL to select the appropriate tiling mode for an optimization target.\r\n
                       0: Balanced\r\n
                       1: OptForSpace\r\n
                       2: OptForSpeed";
        VariableName = "imageTilingOptMode";
        VariableType = "Pal::TilingOptMode";
        VariableDefault = "Pal::TilingOptMode::Balanced";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "ImageTilingPreference";
        SettingType = "UINT_STR";
        Description = "Hints to pal to identify a preference for how this image is organized.\r\n
                       0: Default\r\n
                       1: Standard\r\n
                       2: XMajor\r\n
                       3: YMajor\r\n
                       4: Interleaved";
        VariableName = "imageTilingPreference";
        VariableType = "Pal::ImageTilingPattern";
        VariableDefault = "Pal::ImageTilingPattern::Default";
        SettingScope = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName = "EnableFmaskBasedMsaaRead";
        SettingType = "BOOL_STR";
        Description = "Enable FMASK based MSAA texture reads.\r\n";
        VariableName = "enableFmaskBasedMsaaRead";
        VariableType = "bool";
        VariableDefault = "true";
    }

    Leaf
    {
        SettingName = "EnableHighPriorityDescriptorMemory";
        SettingType = "BOOL_STR";
        Description = "Enable high priority for descriptor memory.\r\n";
        VariableName = "enableHighPriorityDescriptorMemory";
        VariableType = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName = "DisableHtileBasedMsaaRead";
        SettingType = "BOOL_STR";
        Description = "Disable Htile based MSAA texture reads.\r\n";
        VariableName = "disableHtileBasedMsaaRead";
        VariableType = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName = "DisableMsaaStencilShaderRead";
        SettingType = "BOOL_STR";
        Description = "If we know that a MSAA stencil aspect isn't read as a shader resource, give PAL a hint that it's okay to choose a non-TCC format. .\r\n";
        VariableName = "disableMsaaStencilShaderRead";
        VariableType = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName     = "TransferSrcUsageAsShaderReadMask";
        SettingType     = "HEX_STR";
        Description     = "For image created with usage of transfer src, add shader_read in PAL usage if VkImageUsageFlagBits in this mask is set.\r\n";
        VariableName    = "optImgMaskToApplyShaderReadUsageForTransferSrc";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "TransferDstUsageAsShaderWriteMask";
        SettingType     = "HEX_STR";
        Description     = "For image created with usage of transfer dst, add shader_write in PAL usage if VkImageUsageFlagBits in this mask is set.\r\n";
        VariableName    = "optImgMaskToApplyShaderWriteUsageForTransferDst";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "OnlyEnableFP16ForGfx9Plus";
        SettingType     = "BOOL_STR";
        Description     = "Enable extension AMD_GPU_SHADER_HALF_FLOAT and AMD_GPU_SHADER_INT16 only on ASIC >= gfx9.\r\n";
        VariableName    = "optOnlyEnableFP16ForGfx9Plus";
        VariableType    = "bool";
        VariableDefault = "true";
    }

    Leaf
    {
        SettingName     = "ColorTargetUsageDoesNotContainResolveLayout";
        SettingType     = "BOOL_STR";
        Description     = "If set, an image with color target usage bit does not implicitly allow to be in resolve_src or resolve_dst layout. \r\n";
        VariableName    = "optColorTargetUsageDoesNotContainResolveLayout";
        VariableType    = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName     = "RenderStateCacheEnable";
        SettingType     = "HEX_STR";
        Description     = "This bitmask denotes which subset of pipeline render state is cached\r\n
                           at the device-level.  Caching render state enables more efficient redundancy checking when\r\n
                           recording command buffers.  This redundancy checking is mainly limited to pipeline state\r\n
                           that is either invisible to the API (e.g. certain PAL objects) or state that the application\r\n
                           has marked in the pipeline as non-dynamic, meaning its values are programmed during pipeline\r\n
                           bind.\r\n
                           \r\n
                           The following values control for which kinds of state this redundancy checking is enabled:\r\n
                           \r\n
                           0x00000001 - PAL MSAA state objects (all graphics pipelines)\r\n
                           0x00000002 - PAL color blend state objects (all graphics pipelines)\r\n
                           0x00000004 - PAL depth stencil state objects (all graphics pipelines)\r\n
                           0x00000008 - PAL input assembly state params (all graphics pipelines)\r\n
                           0x00000010 - Triangle raster state params (part of every graphics pipeline)\r\n
                           0x00000020 - Point line raster state (only when marked static)\r\n
                           0x00000040 - Depth bias state (only when marked static)\r\n
                           0x00000080 - Blend const state (only when marked static)\r\n
                           0x00000100 - Depth bounds state (only when marked static)\r\n
                           0x00000200 - Viewport state (only when marked static)\r\n
                           0x00000400 - Scissor rect state (only when marked static)";

        VariableName    = "optRenderStateCacheEnable";
        VariableType    = "uint32_t";
        VariableDefault = "0xffffffff";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "IgnoreMutableFlag";
        SettingType     = "BOOL_STR";
        Description     = "If set, the MUTABLE flag on image is ignored\r\n";
        VariableName    = "ignoreMutableFlag";
        VariableType    = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName     = "OptimizeCmdbufMode";
        SettingType     = "UINT_STR";
        Description     = "OptimizeCmdbufMode denotes whether pm4 optimizations will be enabled:\r\n
                          0(EnableOptimizeForRenderPassContinue):  optimizeCmdbuf will be enabled only for render pass continue.\r\n
                          1(EnableOptimizeCmdbuf):                 optimizeCmdbuf will be always enabled .\r\n
                          2(DisableOptimizeCmdbuf):                optimizeCmdbuf will be disabled.\r\n";
        VariableName    = "optimizeCmdbufMode";
        VariableType    = "OptimizeCmdbufMode";
        VariableDefault = "DisableOptimizeCmdbuf";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "PrefetchShaders";
        SettingType     = "BOOL_STR";
        Description     = "If set, shaders are prefetched to warm L2 shader cache.\r\n";
        VariableName    = "prefetchShaders";
        VariableType    = "bool";
        VariableDefault = "false";
    }

    Leaf
    {
        SettingName     = "DccBitsPerPixelThreshold";
        SettingType     = "UINT_STR";
        Description     = "If not UINT_MAX, sets the minimum BPP of surfaces which may have DCC enabled.\r\n";
        VariableName    = "dccBitsPerPixelThreshold";
        VariableType    = "uint32_t";
        VariableDefault = "0xffffffff";
        SettingScope    = "PrivateDriverKey";
    }
}

Node = "Developer Mode"
{
    Leaf
    {
        SettingName     = "DevModePipelineUriServicePostSizeLimit";
        SettingType     = "UINT_STR";
        Description     = "Determines the pipeline binary max size limit (in KB) used by the PipelineUriService when\r\n
                             injecting pipeline binaries back into the driver. The limit is 256KB by default.";
        VariableName    = "devModePipelineUriServicePostSizeLimit";
        VariableType    = "uint32_t";
        VariableDefault = "256";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeElfReplacementDirectoryEnable";
        SettingType     = "BOOL_STR";
        Description     = "This controls whether elf files placed in DevModeElfReplacementDirectory will be read.\r\n";
        VariableName    = "devModeElfReplacementDirectoryEnable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeElfReplacementDirectory";
        SettingType     = "STRING_DIR";
        Description     = "Elf files placed within this directory will be cached and replace corresponding pipeline\r\n
                           binaries as they are created. Elf files within this directory should follow this nomenclature:\r\n
                           \"[exe name]_[hash of pipeline being replaced].elf\"";
        VariableName    = "devModeElfReplacementDirectory";
        VariableType    = "char";
        VariableDefaultWin = "PipelineReplace";
        VariableDefaultLnx = "PipelineReplace";
        StringLength    = "512";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeShaderIsaDbEnable";
        SettingType     = "BOOL_STR";
        Description     = "This controls whether RGP traces will include shader code of created pipelines.\r\n";
        VariableName    = "devModeShaderIsaDbEnable";
        VariableType    = "bool";
        VariableDefault = "true";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeQueueTimingEnable";
        SettingType     = "BOOL_STR";
        Description     = "This controls whether queue operations are timed during RGP traces.\r\n";
        VariableName    = "devModeQueueTimingEnable";
        VariableType    = "bool";
        VariableDefault = "true";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSemaphoreQueueTimingEnable";
        SettingType     = "BOOL_STR";
        Description     = "This controls if the legacy timed queue semaphores are to be used on\r\n
                           Windows instead of the ETW client. This parameter does not affect Linux.\r\n";
        VariableName    = "devModeSemaphoreQueueTimingEnable";
        VariableType    = "bool";
        VariableDefault = "true";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkerEnable";
        SettingType     = "HEX_STR";
        Description     = "This controls what kind of SQTT instrumentation marker data is outputted\r\n
                           from the driver.  Note that this only fine-tunes instrumentation: the\r\n
                           master toggle for SQTT is always whether developer mode is enabled.\r\n
                           \r\n
                           General SQTT data (event, wave, instruction) is also generated independent\r\n
                           of this setting if SQTT is enabled.\r\n
                           \r\n
                           This setting can have a combination of the following values:\r\n
                           \r\n
                           0x0001 - Enable command buffer start instrumentation marker\r\n
                           0x0002 - Enable command buffer end instrumentation marker\r\n
                           0x0004 - Enable per-draw/dispatch event instrumentation markers\r\n
                           0x0008 - Enable barrier instrumentation markers\r\n
                           0x0010 - Enable general API (per entry point call) instrunmentation markers\r\n
                           0x0020 - Enable user event (app string) markers\r\n
                           0x0040 - Enable dispatch events with thread dimensions\r\n
                           0x0080 - Write bound shader hashes as user event markers (requires VK_INTERNAL_DEVELOPER)\r\n
                           0x0100 - Enable pipeline bind markers\r\n";

        VariableName    = "devModeSqttMarkerEnable";
        VariableType    = "uint32_t";
        VariableDefault = "0x16f";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttForceDisable";
        SettingType     = "BOOL_STR";
        Description     = "If true, SQTT support is disabled and all RGP traces will automatically fail.";

        VariableName    = "devModeSqttForceDisable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttWaitIdle";
        SettingType     = "BOOL_STR";
        Description     = "If true, a CPU device wait idle is executed prior to starting and\r\n
                           ending a trace.  PLEASE NOTE: This is currently not thread safe\r\n
                           and may result in crashes.  It is only included as a debugging\r\n
                           option.";

        VariableName    = "devModeSqttWaitIdle";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName     = "DevModeSqttFlushAllQueues";
        SettingType     = "BOOL_STR";
        Description     = "If true, inserts a full pipeline flush into all hardware queues\r\n
                           at the beginning of the last preparation frame in an RGP trace.";
        VariableName    = "devModeSqttFlushAllQueues";
        VariableType    = "bool";
        VariableDefault = "true";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttGpuMemoryLimit";
        SettingType     = "UINT_STR";
        Description     = "Maximum amount of data in bytes to capture per trace.  A trace will cover a span of commands\r\n
                           based on the GpuProfilerGranularity setting.  Defaults to 0, which means auto-calculate the\r\n
                           size based on GPU characteristics.  Current HW requires the size be aligned to 0x1000 bytes.";

        VariableName    = "devModeSqttGpuMemoryLimit";
        VariableType    = "uint32_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttFrameCount";
        SettingType     = "UINT_STR";
        Description     = "Number of frames (present calls) to trace SQTT.";

        VariableName    = "devModeSqttFrameCount";
        VariableType    = "uint32_t";
        VariableDefault = "1";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttInternalUserEventPrefix";
        SettingType     = "STRING";
        Description     = "Any driver-generated user event markers will have this string as its prefix.";

        VariableName    = "devModeSqttInternalUserEventPrefix";
        VariableType    = "char";
        VariableDefault = "[AMD] ";
        StringLength    = "512";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkRenderPasses";
        SettingType     = "BOOL_STR";
        Description     = "If true, driver will insert user event strings of renderpass instances into RGP traces.\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n";

        VariableName    = "devModeSqttMarkRenderPasses";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkPipelineBinds";
        SettingType     = "BOOL_STR";
        Description     = "If true, driver will insert user event strings when pipelines are bound (including shader hashes).\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n";

        VariableName    = "devModeSqttMarkPipelineBinds";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkTargetBinds";
        SettingType     = "BOOL_STR";
        Description     = "If true, driver will insert user event strings when color/depth targets are bound.\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n";

        VariableName    = "devModeSqttMarkTargetBinds";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttMarkPipelineBarriers";
        SettingType     = "BOOL_STR";
        Description     = "If true, driver will insert user event strings when pipeline barriers happen.\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n";

        VariableName    = "devModeSqttMarkPipelineBarriers";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttObjectMetaData";
        SettingType     = "HEX64_STR";
        Description     = "Track metadata for object types (each bit in the mask corresponds with enum value of VkDebugReportObjectTypeEXT).  Set to all f's to track all types.\r\n
                           Setting this will cause any debug names to be included with any of the other internal markings such as pipeline binds.\r\n
                           \r\n
                           Requires internal developer build (VK_INTERNAL_DEVELOPER).\r\n
                           \r\n
                           WARNING: Will likely interfere with multithreaded command buffer recording concurrency.\r\n";

        VariableName    = "devModeSqttTrackObjectMetaData";
        VariableType    = "uint64_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttTraceBeginEndTagEnable";
        SettingType     = "BOOL_STR";
        Description     = "If TRUE, DevModeSqttTrace[Begin|End]TagValues are used to override trace parameter
                           begin/end command buffer debug object tag values.  This is mainly used for debugging.\r\n";

        VariableName    = "devModeSqttTraceBeginEndTagEnable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttTraceBeginTagValue";
        SettingType     = "HEX64_STR";
        Description     = "Custom command buffer debug object tag value signifying virtual frame start.  Requires
                           DevModeSqttTraceBeginEndTagEnable.\r\n";

        VariableName    = "devModeSqttTraceBeginTagValue";
        VariableType    = "uint64_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttTraceEndTagValue";
        SettingType     = "HEX64_STR";
        Description     = "Custom command buffer debug object tag value signifying virtual frame end.  Requires
                           DevModeSqttTraceBeginEndTagEnable.\r\n";

        VariableName    = "devModeSqttTraceEndTagValue";
        VariableType    = "uint64_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttInstructionTraceEnable";
        SettingType     = "BOOL_STR";
        Description     = "If TRUE, instruction-level tracing will be enabled. DevModeSqttTargetApiPsoHash can be
                           used to specify the scope traced (full frame or individual pipeline).\r\n";

        VariableName    = "devModeSqttInstructionTraceEnable";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttTargetApiPsoHash";
        SettingType     = "HEX64_STR";
        Description     = "Target API PSO hash used to trigger instruction level tracing. Full-frame instruction
                           tracing will be enabled if set to 0x0.\r\n";

        VariableName    = "devModeSqttTargetApiPsoHash";
        VariableType    = "uint64_t";
        VariableDefault = "0";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttForceBlockOnTraceEnd";
        SettingType     = "BOOL_STR";
        Description     = "If TRUE, the driver will block immediately after ending a trace to wait for results to
                           complete rather than asynchronously checking for completion during frame boundaries.";

        VariableName    = "devModeSqttForceBlockOnTraceEnd";
        VariableType    = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }

    Leaf
    {
        SettingName     = "DevModeSqttPrepareFrameCount";
        SettingType     = "HEX_STR";
        Description     = "If non-default, this value will override the trace parameter prepare frame count, which is
                           the number of lead frames prior to enabling SQTT that include only queue timing.";

        VariableName    = "devModeSqttPrepareFrameCount";
        VariableType    = "uint32_t";
        VariableDefault = "0xffffffff";
        SettingScope    = "PrivateDriverKey";
    }
}

Node = "Chill"
{
    Leaf
    {
        SettingName = "AllowChill";
        SettingType = "BOOL_STR";
        Description = "Allow chill to run. Chill is a user interaction dependent FPS limiter, \r\n
                       used for power saving.\r\n";
        VariableName = "allowChill";
        VariableType = "bool";
        VariableDefault = "true";
    }
    Leaf
    {
        SettingName = "Chill_ProfileEnable";
        SettingType = "BOOL_STR";
        Description = "If per-app chill profile settings is enabled.\r\n";
        VariableName = "chillProfileEnable";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_ChillLevel";
        SettingType = "HEX_STR";
        Description = "Chill level setting, default is medium:\r\n
                       0x0 - disable,\r\n
                       0x1 - subtle,\r\n
                       0x2 - medium,\r\n
                       0x3 - full,\r\n";
        VariableName = "chillLevel";
        VariableType = "uint32_t";
        VariableDefault = "IcdChillLevelMedium";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_MinFramerate";
        SettingType = "UINT_STR";
        Description = "Min chill frame rate; valid range is 30-300fps.";
        VariableName = "chillMinFrameRate";
        VariableType = "uint32_t";
        VariableDefault = "70";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_MaxFramerate";
        SettingType = "UINT_STR";
        Description = "Max chill frame rate; valid range is 30-300fps.";
        VariableName = "chillMaxFrameRate";
        VariableType = "uint32_t";
        VariableDefault = "144";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_LoadingScreenDrawsThresh";
        SettingType = "UINT_STR";
        Description = "The threshold number of draw calls per frame used to distinguish \r\n
                       between loading screens and gameplay.\r\n";
        VariableName = "chillLoadingScreenDrawsThresh";
        VariableType = "uint32_t";
        VariableDefault = "150";
        SettingScope    = "PrivateDriverKey";
    }
    Leaf
    {
        SettingName = "Chill_IgnoreBaseDriverRestrictions";
        SettingType = "BOOL_STR";
        Description = "When true, we will not disable chill based on KMD workstation flag \r\n
                       or Big Software version.\r\n";
        VariableName = "chillIgnoreBaseDriverRestrictions";
        VariableType = "bool";
        VariableDefault = "false";
        SettingScope    = "PrivateDriverKey";
    }
}

Node = "Shader Tuning"
{
    Leaf
    {
        SettingName = "OverrideShaderParams";
        SettingType = "BOOL_STR";
        Description = "Indicate that shader parameter override is enabled - mainly used for automation";
        VariableName = "overrideShaderParams";
        VariableType = "bool";
        VariableDefault = "false";
    }
    Leaf
    {
        SettingName = "OverrideShaderHashUpper";
        SettingType = "HEX64_STR";
        Description = "Upper 64-bits of the shader hash of shader for which wave parameters are to be overridden";
        VariableName = "overrideShaderHashUpper";
        VariableType = "uint64_t";
        VariableDefault = "0x0";
    }
    Leaf
    {
        SettingName = "OverrideShaderHashLower";
        SettingType = "HEX64_STR";
        Description = "Lower 64-bits of the shader hash of shader for which wave parameters are to be overridden";
        VariableName = "overrideShaderHashLower";
        VariableType = "uint64_t";
        VariableDefault = "0x0";
    }
    Leaf
    {
        SettingName = "OverrideShaderStage";
        SettingType = "UINT_STR";
        Description = "Shader stage for which wave parameters are to be overriden.\r\n
                       0 - Vertex Shader\r\n
                       1 - Tessellation Control Shader\r\n
                       2 - Tessellation Evaluation Shader\r\n
                       3 - Geometry Shader\r\n
                       4 - Fragment Shader\r\n
                       5 - Compute Shader\r\n";
        VariableName = "overrideShaderStage";
        VariableType = "uint32_t";
        VariableDefault = "4";
    }
    Leaf
    {
        SettingName = "OverrideNumVGPRsAvailable";
        SettingType = "UINT_STR";
        Description = "Override number of available VGPRs for the shader specified by overrideShaderCrcUpper/Lower";
        VariableName = "overrideNumVGPRsAvailable";
        VariableType = "uint32_t";
        VariableDefault = "0";
    }
    Leaf
    {
        SettingName = "OverrideWavesPerCu";
        SettingType = "UINT_STR";
        Description = "Override number of waves per CU for the shader specified by overrideShaderCrcUpper/Lower";
        VariableName = "overrideWavesPerCu";
        VariableType = "uint32_t";
        VariableDefault = "0";
    }
    Leaf
    {
        SettingName = "OverrideUserDataSpillThreshold";
        SettingType = "UINT_STR";
        Description = "Force PAL to spill user data registers to memory for the shader specified by overrideShaderCrcUpper/Lower";
        VariableName = "overrideUserDataSpillThreshold";
        VariableType = "bool";
        VariableDefault = "false";
    }
    Leaf
    {
        SettingName = "OverrideMaxLdsSpillDwords";
        SettingType = "UINT_STR";
        Description = "Set the max LDS spill size in DWORDs for the shader specified by overrideShaderCrcUpper/Lower";
        VariableName = "overrideMaxLdsSpillDwords";
        VariableType = "uint32_t";
        VariableDefault = "0";
    }
    Leaf
    {
        SettingName = "OverrideCsTgPerCu";
        SettingType = "UINT_STR";
        Description = "Set the thread-group per CU limit for compute shaders.";
        VariableName = "overrideCsTgPerCu";
        VariableType = "uint32_t";
        VariableDefault = "0";
    }
    Leaf
    {
        SettingName = "OverrideUsePbbPerCrc";
        SettingType = "HEX_STR";
        Description = "Set option to disable PBB for shader specified by OverrideShaderCrcUpper and\r\n
                       OverrideShaderCrcLower\r\n
                       0 - PipelineBinningModeDefault - Follow the behavior of the PipelineBinningMode setting\r\n
                       1 - PipelineBinningModeDisable - Force PBB off for shader\r\n
                       2 - PipelineBinningModeEnable  - Force PBB on for shader\r\n";
        VariableName = "overrideUsePbbPerCrc";
        VariableType = "PipelineBinningMode";
        VariableDefault = "PipelineBinningModeDefault";
    }
    Leaf
    {
        SettingName = "OverrideAllowReZ";
        SettingType = "BOOL_STR";
        Description = "Override allowReZ for the shader specified by OverrideShaderHashUpper/Lower.";
        VariableName = "overrideAllowReZ";
        VariableType = "bool";
        VariableDefault = "false";
    }
}

Node = "Public CCC Options"
{
    Leaf
    {
        SettingType = "UINT_STR";
        Description = "Specifies the GPU ID (composed of PCI info).";
        VariableName = "appGpuID";
        VariableType = "uint32_t";
        VariableDefault = "0";
        SettingScope = "PublicCatalystKey";
    }
    Leaf
    {
        SettingType = "UINT_STR";
        Description = "Controls texture filtering optimizations exposed by CCC.";
        VariableName = "vulkanTexFilterQuality";
        VariableType = "TextureFilterOptimizationSettings";
        VariableDefault = "TextureFilterOptimizationsEnabled";
        SettingScope = "PublicCatalystKey";
    }
}
